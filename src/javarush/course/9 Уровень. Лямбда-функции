// Предыстория появления Лямбда-выражений
// Функциональный метод


Предыстория появления Лямбда-выражений
Интерфейсы
Интерфейс — это разновидность класса. Сильно урезанная, если можно так сказать. У интерфейса, в отличие от класса, не может быть своих переменных (кроме статических).
Также нельзя создавать объекты типа Интерфейс:
Нельзя объявлять переменные класса
Нельзя создавать объекты
Так зачем же интерфейс нужен? Интерфейсы используются только совместно с наследованием. Один и тот же интерфейс могут наследовать разные классы,
или еще говорят, что классы реализуют интерфейс.
Если класс реализует интерфейс, он обязан реализовать у себя внутри те методы, которые были объявлены, но не реализованы внутри интерфейса
Сортировка
Чтобы сортировать коллекцию строк в алфавитном порядке, в Java есть отличный метод — Collections.sort(коллекция);
Этот статический метод выполняет сортировку переданной коллекции, и в процессе сортировки попарно сравнивает ее элементы: чтобы понять, менять элементы местами или нет.
Сравнение элементов в процессе сортировки выполняется с помощью метода compareTo(), который есть у всех стандартных классов: Integer, String, ...
Если мы хотим сортировать строки не по алфавиту, а по их длине, и числа хотим сортировать в порядке убывания:
Для этого у класса Collections есть еще один метод sort(), но уже с двумя параметрами:
Collections.sort(коллекция, компаратор);
Лямбда-выражения в Java
Comparator<String> comparator = (String obj1, String obj2) ->
{
    return obj1.length() - obj2.length();
};
У компилятора не возникнет проблем с определением метода, т.к. лямбда-выражение можно писать только для интерфейсов, у
которых метод один. Впрочем есть способ обойти это правило, но об этом вы узнаете, когда начнете изучать ООП активнее (мы говорим о default-методах).
Лямбда-выражение можно записать там, где используется тип-интерфейс с одним-единственным методом.
Например, в этом коде Collections.sort(list, (obj1, obj2) -> obj1.length() - obj2.length()); можно записать лямбда-выражение,
т.к. сигнатура метода sort() имеет вид: sort(Collection<T> colls, Comparator<T> comp)
Когда мы передали в метод sort в качестве первого параметра коллекцию ArrayList<String>, компилятор смог определить тип второго
параметра как Comparator<String>. А из этого сделал вывод, что этот интерфейс имеет единственный метод int compare(String obj1, String obj2)

Функциональный метод
Если у интерфейса есть только один метод, переменной этого типа-интерфейса можно присвоить значение, заданное лямбда-выражением (лямбда-функцией).
Такие интерфейсы стали называть функциональными интерфейсами (после добавления в Java поддержки лямбда-функций
Например, в Java есть интерфейс Consumer<Тип> (Consumer == Потребитель), который содержит метод accept(Тип obj). Зачем же нужен этот интерфейс?
В Java 8 у коллекций появился метод forEach(), который позволяет для каждого элемента коллекции выполнить какое-нибудь действие.
И вот для передачи действия в метод forEach() как раз и используется функциональный интерфейс Consumer<T>.
Ссылка на метод
list.forEach( System.out::println );
объект::метод
x -> объект.метод(x)
мы хотели для каждого элемента коллекции list выполнять какое-то действие. Если это действие — вызов одной функции (такой как println()),
было бы разумно просто передать функцию в метод в качестве параметра.
А как объяснить компилятору, что функцию нужно именно передать, а не вызвать? Для этого перед именем метода ставим не точку, а два двоеточия