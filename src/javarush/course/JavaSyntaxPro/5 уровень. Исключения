// Исключения в Java-программах
// Выбрасывание исключений
// Виды исключений в Java
// Зарезервированные слова в Java
// Stack trace

// Исключения в Java: перехват и обработка https://javarush.com/groups/posts/1943-iskljuchenija-perekhvat-i-obrabotka
// Исключения (Exception): checked, unchecked и свои собственные https://javarush.com/groups/posts/1944-iskljuchenija-checked-unchecked-i-svoi-sobstvennihe



Исключения
Когда в Java-программе возникает ошибка, например, деление на 0, происходят такие замечательные вещи:
Шаг первый
Создается специальный объект-исключение, в котором содержится информация о произошедшей ошибке.
Объекты-исключения имеют свои классы, и все их отличие от обычных классов в том, что они унаследованы от класса Throwable
Шаг второй
Объект-исключение «выбрасывается». Не сильно удачное название. «Выбрасывание исключения» по своей сути больше похоже на
включение пожарной сигнализации или оповещение «боевая тревога».
Когда в систему «выброшено исключение», нормальный режим работы программы прекращается, и начинается «работа по аварийному протоколу».
Шаг третий

Текущий метод, в котором возникло (выброшено) исключение, немедленно завершается. Исключение передается в вызывающий метод,
который тоже немедленно завершается. И так по цепочке, пока не завершится метод main. Вместе с завершением метода main завершается и программа.
Смысл в том, что в вашей программе можно перехватывать исключения определенного типа и писать свою логику обработки аварийных ситуаций.
Перехват исключений try-catch
В Java есть механизм перехвата исключений, который позволяет прекратить аварийное завершение методов. Выглядит он так:
try
{
   код, где может возникнуть ошибка
}
catch(ТипИсключения1 имя1)
{
   код обработки исключения1
}
catch(ТипИсключения2 имя2)
{
   код обработки исключения2
}
Исключение, возникшее в блоке try, может быть захвачено только одним блоком catch. Не может быть ситуации, что при обработке
исключения выполнился код из нескольких блоков catch.
Однако порядок блоков имеет значение.
Может быть ситуация, когда исключение захвачено несколькими блоками. В этом случае оно будет захвачено блоком catch, который идет раньше (ближе к блоку try)
Оператор throw
Исключение, пока оно не выброшено в систему, или когда оно уже перехвачено блоком catch — это в принципе просто объект класса,
унаследованного от Exception (вернее, от Throwable). Никакими магическими особенностями сам объект-исключение не обладает.
Вся логика работы исключений — это просто особый сценарий поведения Java-машины, когда в ее среду выполнения вброшено исключение.
Вы всегда можете снова вбросить Java-машине исключение, которое только что перехватили. Для этого нужно использовать оператор throw:
throw исключение;
Еще один важный момент. Иногда программисту нужно сделать некоторые действия независимо от того, было исключение в коде или нет.
Например, в коде мы открыли файл на запись, а открытый файл нужно обязательно закрыть вызовом метода close().
Для выполнения таких обязательных действий к оператору try-catch добавили еще один блок — finally, и получился оператор try-catch-finally
Кстати, если вы не хотите перехватывать исключение, а блок finally вам нужен, используйте сокращенную запись блока try-catch-finally — try-finally.
Выглядит это примерно так:
try
{
   код, где может возникнуть ошибка
}
finally
{
   код, который нужно выполнить в любом случае
}

Виды исключений в Java
Все исключения делятся на 4 вида, которые на самом деле являются классами, унаследованными друг от друга: Error -> Throwable <- Exception <- RuntimeException
Throwable
Самым базовым классом для всех исключений является класс Throwable. В классе Throwable содержится код, который записывает
текущий стек-трейс вызовов функций в массив.
Класс Error
Следующим классом исключений является класс Error — прямой наследник класса Throwable. Объекты типа Error (и его классов-наследников)
создает Java-машина в случае каких-то серьезных проблем, например, сбой в работе, нехватка памяти, и т.д.
Класс Exception
Исключения типа Exception (и RuntimeException) — это обычные ошибки, которые возникают во время работы многих методов.
Цель каждого выброшенного исключения — быть захваченным тем блоком catch, который знает, что нужно сделать в этой ситуации.
Класс RuntimeException
RuntimeException — это разновидность (подмножество) исключений Exception. Можно даже сказать, что RuntimeException — это облегченная версия
обычных исключений (Exception): на такие исключения налагается меньше требований и ограничений
Все исключения, унаследованные от классов RuntimeException и Error, считаются unchecked-исключениями, все остальные — checked-исключениями.
К checked-исключениям есть дополнительные требования. Звучат они примерно так.
Требование 1
Если метод выбрасывает checked-исключение, он должен содержать тип этого исключения в своем заголовке (сигнатуре метода). Чтобы все методы, которые вызывают данный метод, знали о том, что в нем может возникнуть такое «важное исключение».
Указывать checked-исключения надо после параметров метода после ключевого слова throws (не путать со throw). Выглядит это примерно так:
тип метод (параметры) throws исключение
Требование 2
Если вы вызываете метод, у которого в сигнатуре прописаны checked-исключения, то вы не можете проигнорировать этот факт.
Вы должны либо перехватить все эти исключения, добавив блоки catch для каждого из них, либо добавить их в throws своего метода.
Вызов можно обработать 3 способами:
1. Не перехватываем возникающие исключения
Чаще всего это делается в случае, когда в методе не известно, как правильно обработать эту ситуацию.
public void создатьНаселенныйМир(int population)
throws ПустойМир, ОдинокийМир
{
   создатьМир(population);
}
Вызывающий метод не перехватывает исключения и вынужден информировать о них других: добавить их себе в throws
2. Перехватывать часть исключений
Обрабатываем понятные ошибки, непонятные — прокидываем в вызывающий метод. Для этого нужно добавить их название в throws:
public void создатьНепустойМир(int population)
throws ПустойМир
{
   try
   {
      создатьМир(population);
   }
   catch (ОдинокийМир e)
   {
      e.printStackTrace();
   }
}
Вызывающий метод перехватывает только одно checked-исключение – ОдинокийМир, второе он должен добавить в свою сигнатуру: указать после слова throws
3. Перехватываем все исключения
Если метод не прокидывает исключения вызывающему методу, вызывающий метод всегда будет уверен, что все выполнилось хорошо.
И не сможет предпринять никаких действий, чтобы исправить ситуацию.
public void создатьЛюбойМир(int population)
{
   try
   {
      создатьМир(population);
   }
   catch(ОдинокийМир e)
   {
      e.printStackTrace();
   }
   catch(ПустойМир e)
   {
      e.printStackTrace();
   }
}
В этом методе перехватываются все ошибки. Вызывающий метод будет уверен, что все прошло отлично.
Обертывание исключений
(тк проблем от checked-исключений гораздо больше, чем пользы, тк почти бесконечная передача в другие выше стоящие методы)
Java-программисты предложили «заворачивать» checked-исключения внутрь RuntimeException. Другими словами, перехватывать все checked-исключения,
создавать вместо них unchecked-исключения (например, RuntimeException) и выбрасывать уже их. Выглядит это все примерно так:
try
{
   код, где может возникнуть checked-исключение
}
catch(Exception exp)
{
   throw new RuntimeException(exp);
}
Множественный перехват исключений
Программисты очень не любят дублирование кода. Даже придумали такой принцип разработки — DRY: Don’t Repeat Yourself
try
{
   код, где может возникнуть ошибка
}
catch(ТипИсключения1 | ТипИсключения2 | ТипИсключения3 имя)
{
   код обработки исключений
}

Собственные исключения
Вы всегда можете создать свой собственный класс-исключение. Просто унаследовав класс от, например, RuntimeException. Выглядеть это будет примерно так:
class ИмяКласса extends RuntimeException
{
}

Список слов
В языке Java, как и в любом языке программирования, есть слова, которые имеют особый смысл. Например, return или if или while
Такие слова называются ключевыми (keywords) и считаются зарезервированными языком Java.
Вы не можете использовать эти слова в качестве имени переменной, имени метода или класса. Компилятор всегда будет интерпретировать
их строго определенным образом. Всего в Java таких слов 54.
Примитивные типы. 8 примитивных типов, и каждому из них соответствует свое ключевое слово:
- byte short int long char float double boolean void
Циклы и ветвления тоже дают нам немаленький список ключевых слов:
- if else switch case default while do for break continue
Исключения дают нам 5 ключевых слов:
- try catch finally throw throws
Области видимости
- private protected public
Работа с классами 11 ключевых слов:
- class interface enum import package extends implements static final abstract default
Работа с объектами и переменными. Еще 6 ключевых слов используются для работы с объектами, методами и переменными
- new instanceof this super return var (начиная с Java 10)
Многопоточность на уровне синтаксиса языка Java представлена всего двумя словами
- synchronized volatile
Разное. Так же есть еще 4 уникальных ключевых слова:
- native transient assert strictfp
Зарезервированы, но не используются
- const goto
Не ключевые слова - формально не относятся к ключевым словам
- true false null

Stack trace
Программы на языке C++ после компиляции превращаются в один большой файл машинного кода и все, что во время выполнения
доступно программисту, — это адрес куска памяти, который содержит машинный код, который сейчас выполняется. Не густо, скажем так.
В Java же, даже после компиляции, классы остаются классами, методы и переменные никуда не деваются, и у программиста есть
много способов получить данные о том, что сейчас происходит в программе.
Например, в любой момент работы программы можно узнать класс и имя метода, который сейчас выполняется. И даже не одного
метода, а получить информацию о всей цепочке вызовов методов от текущего метода до метода main().
Список, состоящий из текущего метода, метода, который его вызвал, его вызвавшего метода и т.д., называется stack trace.
Получить его можно с помощью команды:
StackTraceElement[] methods = Thread.currentThread().getStackTrace();
Статический метод currentThread() класса Thread возвращает ссылку на объект типа Thread, который содержит информацию о
текущей нити (о текущем потоке выполнения). Подробнее о нитях вы узнаете в квесте Java Core.
У этого объекта Thread есть метод getStackTrace(), который возвращает массив элементов StackTraceElement, каждый из которых
содержит информацию об одном методе. Все элементы вместе и образуют stack trace.
Стек (Cтопка) — это структура хранения данных, в которую можно добавлять элементы и из которой можно забирать элементы. Причем
брать элементы можно только с конца: сначала последний добавленный, потом — предпоследний, и т.д.
T push(T obj)           Добавляет элемент obj в конец списка (наверх стопки)
T pop()                 Забирает элемент с верха стопки (высота стопки уменьшается)
T peek()                Возвращает элемент с верха стопки (стопка не меняется)
boolean empty()         Проверяет, не пуста ли коллекция
int search(Object obj)  Ищет объект из коллекции, возвращает его index

