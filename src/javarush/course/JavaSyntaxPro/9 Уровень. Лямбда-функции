// Предыстория появления Лямбда-выражений
// Функциональный метод
// Потоки данных
// Работа с потоками, часть 1
// Работа с потоками, часть 2
// Работа с потоками, часть 3

// Популярно о лямбда-выражениях в Java. С примерами и задачами. Часть 1 https://javarush.com/groups/posts/264
// Популярно о лямбда-выражениях в Java. С примерами и задачами. Часть 2 https://javarush.com/groups/posts/283



Предыстория появления Лямбда-выражений
Интерфейсы
Интерфейс — это разновидность класса. Сильно урезанная, если можно так сказать. У интерфейса, в отличие от класса, не может быть своих переменных (кроме статических).
Также нельзя создавать объекты типа Интерфейс:
Нельзя объявлять переменные класса
Нельзя создавать объекты
Так зачем же интерфейс нужен? Интерфейсы используются только совместно с наследованием. Один и тот же интерфейс могут наследовать разные классы,
или еще говорят, что классы реализуют интерфейс.
Если класс реализует интерфейс, он обязан реализовать у себя внутри те методы, которые были объявлены, но не реализованы внутри интерфейса
Сортировка
Чтобы сортировать коллекцию строк в алфавитном порядке, в Java есть отличный метод — Collections.sort(коллекция);
Этот статический метод выполняет сортировку переданной коллекции, и в процессе сортировки попарно сравнивает ее элементы: чтобы понять, менять элементы местами или нет.
Сравнение элементов в процессе сортировки выполняется с помощью метода compareTo(), который есть у всех стандартных классов: Integer, String, ...
Если мы хотим сортировать строки не по алфавиту, а по их длине, и числа хотим сортировать в порядке убывания:
Для этого у класса Collections есть еще один метод sort(), но уже с двумя параметрами:
Collections.sort(коллекция, компаратор);
Лямбда-выражения в Java
Comparator<String> comparator = (String obj1, String obj2) ->
{
    return obj1.length() - obj2.length();
};
У компилятора не возникнет проблем с определением метода, т.к. лямбда-выражение можно писать только для интерфейсов, у
которых метод один. Впрочем есть способ обойти это правило, но об этом вы узнаете, когда начнете изучать ООП активнее (мы говорим о default-методах).
Лямбда-выражение можно записать там, где используется тип-интерфейс с одним-единственным методом.
Например, в этом коде Collections.sort(list, (obj1, obj2) -> obj1.length() - obj2.length()); можно записать лямбда-выражение,
т.к. сигнатура метода sort() имеет вид: sort(Collection<T> colls, Comparator<T> comp)
Когда мы передали в метод sort в качестве первого параметра коллекцию ArrayList<String>, компилятор смог определить тип второго
параметра как Comparator<String>. А из этого сделал вывод, что этот интерфейс имеет единственный метод int compare(String obj1, String obj2)

Функциональный метод
Если у интерфейса есть только один метод, переменной этого типа-интерфейса можно присвоить значение, заданное лямбда-выражением (лямбда-функцией).
Такие интерфейсы стали называть функциональными интерфейсами (после добавления в Java поддержки лямбда-функций
Например, в Java есть интерфейс Consumer<Тип> (Consumer == Потребитель), который содержит метод accept(Тип obj). Зачем же нужен этот интерфейс?
В Java 8 у коллекций появился метод forEach(), который позволяет для каждого элемента коллекции выполнить какое-нибудь действие.
И вот для передачи действия в метод forEach() как раз и используется функциональный интерфейс Consumer<T>.
Ссылка на метод
list.forEach( System.out::println );
объект::метод
x -> объект.метод(x)
мы хотели для каждого элемента коллекции list выполнять какое-то действие. Если это действие — вызов одной функции (такой как println()),
было бы разумно просто передать функцию в метод в качестве параметра.
А как объяснить компилятору, что функцию нужно именно передать, а не вызвать? Для этого перед именем метода ставим не точку, а два двоеточия
Конструктор
Ссылки на методы с помощью двойного двоеточия очень удобно использовать, когда мы будем работать с потоками ввода-вывода
Ссылка на метод объекта
Чтобы передать ссылку на метод объекта, нужно записать код вида объект::метод.
Этот код эквивалентен коду x -> объект.метод(x)
В качестве объекта могут фигурировать такие специальные переменные как this и super
Ссылка на метод класса
Чтобы передать ссылку на статический метод, нужно записать код вида класс::метод. Этот код будет преобразован к коду вида x -> класс.метод(x);
Ссылка на конструктор
Конструктор по своему поведению чем-то похож на статический метод класса, поэтому на него тоже можно передать ссылку. Выглядит это так: класс::new.
Например, можно обойти стирание типов у коллекций и передать в метод toArray() ссылку на конструктор, который создаст нужный массив: toArray( int[]::new );

Потоки данных
Интерфейс Stream
Stream<T>. Где T — это тип-параметр, обозначающий тип данных, которые передаются в потоке.
Stream<Тип> имя = коллекция.stream();
После создания объекта Stream<Тип> никакого движения данных не происходит. Мы просто получили объект-поток для того, чтобы начать строить цепочку из потоков-данных.

Работа с потоками, часть 1
Список методов типа Stream
Методы	                    Описание
Stream<T> of()              Создает поток из набора объектов
Stream<T> generate()        Генерирует поток по заданному правилу
Stream<T> concat()          Объединяет вместе несколько потоков
Stream<T> filter()          Фильтрует данные: пропускает только данные, которые соответствуют заданному правилу
Stream<T> distinct()        Удаляет дубликаты: не пропускает данные, которые уже были
Stream<T> sorted()          Сортирует данные
Stream<T> peek()            Выполняет действие над каждым данным
Stream<T> limit(n)          Обрезает данные после достижения лимита
Stream<T> skip(n)           Пропускает первые n данных
Stream<R> map()             Преобразовывает данные из одного типа в другой
Stream<R> flatMap()         Преобразовывает данные из одного типа в другой
boolean anyMatch()          Проверяет, что среди данных потока есть хоть одно, которое соответствует заданному правилу
boolean allMatch()          Проверяет, что все данные в потоке соответствуют заданному правилу
boolean noneMatch()         Проверяет, что никакие данные в потоке не соответствуют заданному правилу
Optional<T> findFirst()     Возвращает первый найденный элемент, который соответствует правилу
Optional<T> findAny()       Возвращает любой элемент из потока, который соответствует правилу
Optional<T> min()           Ищет минимальный элемент в потоке данных
Optional<T> max()           Возвращает максимальный элемент в потоке данных
long count()                Возвращает количество элементов в потоке данных
R collect()                 Вычитывает все данные из потока и возвращает их в виде коллекции
Intermediate и terminal методы Stream
Промежуточные методы
Промежуточные методы возвращают объект, который имплементирует интерфейс Stream, и их можно выстроить в цепочку вызовов.
Конечные методы
Конечные методы возвращают значение, тип которого отличен от типа Stream.
Цепочка вызовов методов
Таким образом, вы можете строить цепочки вызовов из любого количества промежуточных методов и в конце вызывать один конечный.
Внутри потока данных, данные вообще не меняются. Цепочка промежуточных методов – это хитрый (декларативный) способ указания некой
последовательности обработки данных, которая начнет выполняться после вызова терминального (конечного) метода.
Сравнение промежуточных и конечных методов:
                                                                            промежуточные	                    конечные
Тип возвращаемого значения	                                                Stream	                            не Stream
Возможность объединения нескольких методов данного типа в цепочку вызовов	да	                                нет
Количество методов в одной цепочке вызовов	                                любое	                            не более одного
Производит конечный результат	                                            нет	                                да
Запускает обработку данных в потоке	                                        нет	                                да
.flatMap(owner -> owner.getPets().stream())         переход от Stream<Owner> к Stream<Pet>
.filter(pet -> Cat.class.equals(pet.getClass()))    в потоке данных оставляем только котов
.filter(cat -> Color.FOXY == cat.getColor())        в потоке данных оставляем только рыжих
.sorted((o1, o2) -> o2.getAge() - o1.getAge())      сортируем по возрасту в убывающем порядке
.map(Animal::getName)                               берем имена
.collect(Collectors.toList())                       результат складываем в список
Создание потоков
Метод of() создает поток, состоящий из одного элемента Stream<Integer> stream = Stream.of(1);
Метод of() создает поток, состоящий из переданных элементов. Количество элементов может быть любым Метод Stream<T> Stream.of(T obj1, T obj2, T obj3, ...
Метод Stream<T> Stream.generate(Supplier<T> obj)
Метод generate() позволяет задать правило, по которому будет генерироваться очередной элемент потока при его запросе.
Например, можно каждый раз отдавать случайное число Stream<Double> s = Stream.generate(Math::random);
Метод Stream<T> Stream.concat(Stream<T> a, Stream<T> b)
Метод concat() объединяет два переданных потока в один. При чтении данных сначала будут прочитаны данные из первого потока, а затем из второго
Фильтрация данных
Метод Stream<T> filter(Predicate<T>)
Этот метод возвращает новый поток данных, который фильтрует данные из потока-источника согласно переданному правилу
Stream<Integer> stream2 = stream.filter(x -> (x < 3));
Метод Stream<T> sorted(Comparator<T>)
Этот метод возвращает новый поток данных, который сортирует данные из потока-источника. В качестве параметра можно передать компаратор,
который будет задавать правила сравнения двух элементов потока данных.
Метод Stream<T> peek(Consumer<T>)
Этот метод возвращает новый поток данных, хотя данные в нем те же, что и в потоке источнике. Но когда запрашивается очередной элемент из потока, для него вызывается функция, которую вы передали в метод peek().
Если в метод peek() передать функцию System.out::println, тогда все объекты будут выводиться на экран в момент, когда они будут проходить через поток.

Работа с потоками, часть 2
Также у класса Stream<T> есть метод, который позволяет преобразовать данные из одного типа в другой. Этот метод называется map().
Он тоже возвращает поток Stream<R>, но уже с элементами нового типа. В качестве параметра в метод map() нужно передать функцию,
которая преобразовывает один тип данных в другой
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
Stream<String> stream2 = stream.map((x) -> String.valueOf(x));
Преобразование строки в URI
ArrayList<String> list = new ArrayList<String>();
list.add("https://google.com");
list.add("https://linkedin.com");
list.add("https://yandex.com");
Stream<URI> stream = list.stream().map( URI::new );
Исключения
Код выше должен работать, но он работать не будет — программа не скомпилируется. И не потому, что мы где-то сделали ошибку, а потому, что ее сделали разработчики Java.
Когда-то давно им пришла в голову замечательная идея — добавить в конструктор(!) класса URI checked-исключение URISyntaxException.
А такие исключения нужно обязательно заворачивать в try-catch.

Работа с потоками, часть 3
У класса Stream есть три стандартных метода, которые не конструируют потоки, а проверяют, что за данные находятся в этих потоках.
Это методы: anyMatch(), allMatch() и noneMatch().
anyMatch() Этот метод проверяет, что в потоке есть хотя бы один элемент
Если такой элемент есть, метод возвращает true, иначе — false.
Метод boolean allMatch(правило)
Этот метод проверяет, что все элементы в потоке соответствуют правил
Метод boolean noneMatch(правило)
Метод noneMatch() проверяет, что в потоке нет ни одного элемента, который соответствует переданному правилу.
Противоположный по смыслу метод к методу anyMatch()
Служебные классы: класс Optional
Иногда программистам очень неудобно работать с ссылками на null. Например, вы сравниваете две строки.
Если обе переменные не null, тогда можно просто вызвать s1.equals(s2), и все будет работать. А вот если s1 может быть null,
придется писать код, который учитывает эту ситуацию, чтобы не возникло NullPointerException
Код	                                                   Примечание
class Optional<Tип>
{
   private final Tип value;
   private Optional() { this.value = null;}
   private Optional(value) { this.value = value;}
   public static <Tип> Optional<Tип> of(Tип value)
   {
      return new Optional<Tип>(value);
   }

   public boolean isPresent()                          Проверяет, что внутри находится значение (ссылка не null)
   {
      return value != null;
   }

   public boolean isEmpty()                            Проверяет, что объект хранит ссылку на null
   {
      return value == null;
   }

   public Tип get()                                    Возвращает значение, которое хранит. Кидает исключение, если значения нет.
   {
      if (value == null)
      {
         throw new NoSuchElementException();
      }
      return value;
   }

   public Tип orElse(Tип other)                        Возвращает значение, или если внутри хранится null, то переданное в метод второе значение
   {
      return value != null ? value : other;
   }

   public Tип orElseThrow()                            Возвращает значение или кидает исключение, если значения нет.
   {
      if (value == null)
      {
         throw new NoSuchElementException();
      }
      return value;
   }
}
Цель этого класса – просто хранить в себе объект T (ссылку на объект типа T). Ссылка на объект внутри класса Optional<T> может быть null.
Этот класс позволяет писать программистам код немного красивее. Сравните:
С использованием Optional
public void printString(String s)
{
   Optional<String> str = Optional.ofNullable(s);
   System.out.println(str.orElse(""));
}
Без использования Optional
public void printString(String s)
{
   String str = s != null ? s : "";
   System.out.println(str)
}
Один объект Optional всегда можно сравнить с другим объектом Optional через метод equals, даже если они хранят в себе ссылки на null.
Класс Optional позволяет «более красиво» записывать проверки на null и действия в случае, если внутри объект Optional хранится null.
Поиск элементов
У класса Stream есть еще 4 метода, которые позволяют искать элементы в потоке. Это методы findFirst(), findAny(), min() и max()
Последний метод get() — это просто вытаскивание значения, которое хранится внутри объекта Optional
Метод findAny() возвращает любой элемент из потока и на этом завершается. Этот метод — это аналог метода findFirst(),
только для потоков, которые обрабатываются параллельно.
При параллельной обработке потоков может случиться такая ситуация, что в какой-то части потока элемент уже найден, но пока еще не понятно, будет он первым или нет.
Если элементов, которые прошли все фильтры, много и для программиста принципиально получить именно первый из них, следует вызывать метод findFirst().
Если программист знает, что реально через все фильтры пройдет 0 или 1 элемент, тогда достаточно просто вызвать findAny() — так будет быстрее

Коллекторы в Java
Сбор элементов
collect() используется для того, чтобы перейти от потоков к привычным коллекциям — List<T>, Set<T>, Map<T, R> и другим
В метод collect() нужно передать специальный объект — collector. Этот объект вычитывает все данные из потока, преобразует
их к определенной коллекции и возвращает ее. А следом за ним эту же коллекцию возвращает и сам метод collect.
Все это сделано довольно хитро: объект collector имеет тип Collector<T, A, R> – у него аж три типа-параметра.
Последний тип R — это обычно и есть тип вроде List<T>. Поэтому компилятор может по этому типу подставить правильный тип результата самого метода collect().
toList()                    Объект, который преобразует поток в список — List<T>
toSet()                     Объект, который преобразует поток во множество — Set<T>
toMap()                     Объект, который преобразует поток в мэп — Map<K, V>
joining()                   Склеивает элементы потока в одну строку
mapping()                   Преобразует элементы потока в Map<K, V>
groupingBy()                Группирует элементы, возвращает Map <K, V>








