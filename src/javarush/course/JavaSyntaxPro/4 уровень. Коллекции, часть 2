// Много работать — не путь к успеху, но работать мало — путь к поражению

// Коллекция HashSet
// Цикл for-each
// Вспомогательный класс Collections
// Знакомство с коллекцией HashMap
// Знакомство с коллекцией LinkedList
// Новый тип данных – enum: перечисление
// Оператор множественного выбора в Java: switch

// Класс Collections https://javarush.com/groups/posts/1937-klass-collections
// Цикл for-each в Java https://javarush.com/groups/posts/for-each-java
// Оператор switch в Java https://javarush.com/groups/posts/operator-switch-v-java
// LinkedList https://javarush.com/groups/posts/1938-linkedlist
// HashMap — что за карта такая? https://javarush.com/groups/posts/1940-klass-hashmap-
// Как использовать класс Enum https://javarush.com/groups/posts/1963-kak-ispoljhzovatjh-klass-enum
// Enum в Java. Практические примеры. Добавление конструкторов и методов https://javarush.com/groups/posts/2260-enum-prakticheskie-primerih-dobavlenie-konstruktorov-i-metodov



Коллекция HashSet
Контейнерами или коллекциями называют классы, которые позволяют хранить и обрабатывать много объектов сразу. Например массивы и списки.
Тип коллекции -	Класс      - Описание
List          - ArrayList  - Список
              - LinkedList - Связный список
              - Vector     - Вектор
              - Stack      - Стэк (стопка)
Set           - HashSet    - Множество          HashSet<Тип> имя = new HashSet<Тип>();
              - TreeSet
              - LinkedHashSet
Queue         - PriorityQueue - Очередь
                ArrayDeque
Коллекции же в широком смысле принято называть контейнерами. К ним относятся классы типа Map и массивы.
Map           - HashMap     - Карта/Словарь
              - TreeMap
              - HashTable
Коллекция Set создана для хранения множества элементов. Поэтому ее так и называют Set (множество). У этой коллекции есть три особенности.
Операции над множеством
С множеством можно делать только три операции: добавлять элементы во множество, удалять элементы из множества и проверять,
есть ли во множестве определенный элемент. Все.
Отсутствие порядка
У элементов этой коллекции нет номеров. Нельзя получить элемент по его индексу или записать значение в коллекцию по определенному
индексу. Методов get() и set() у множества нет.
Уникальность элементов
Все элементы множества уникальны. В отличие от списка, в множестве один элемент может быть только раз. Объект или находится
во множестве, или нет: третьего не дано. Нельзя во «множество цветов» трижды добавить «черный цвет». Он там либо есть, либо его нет.
Поиск элементов
Когда вы добавляете во множество новый элемент, удаляете элемент, или проверяете наличие элемента, внутри метода выполняется
поиск элемента. Элементы коллекции и переданный элемент сравниваются сначала по hashCode(), а если hashCode() совпадают, по equals.

Цикл for-each
Например у hashSet нет номеров, и тк гет и сет нельзя вызвать появился for-each
Итератор — это специальный объект у коллекции, который помогает обойти все элементы коллекции и не повторяться.
Получить итератор у любой коллекции можно с помощью кода: Iterator<Тип> it = имя.iterator();
Где имя — это имя переменной-коллекции, Тип — это тип элементов коллекции. iterator() — это метод коллекции. it — это имя переменной-объекта-итератора.
Итератор
Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Он возвращает итератор - то есть объект, реализующий интерфейс Iterator.
Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить следующий элемент и тд
   ArrayList<String> list = new ArrayList<String>();
      Iterator<String> it = list.iterator();
   while (it.hasNext())
   {
      String str = it.next();
      System.out.println(str);
   }
Цикл фор
    ArrayList<String> list = new ArrayList<String>();

    for (int i = 0; i < list.size(); i++)
    {
       String str = list.get(i);
       System.out.println(str);
    }
for-each
    for(Тип имя:коллекция)
    ArrayList<String> list = new ArrayList<String>();

    for (String str: list)
    {
       System.out.println(str);
    }
Нельзя менять коллекцию в for-each, пока вы обходите ее с помощью итератора, тк возникнет ошибка, но есть 3 варианта обойти ошибку:
1
    public static void removeBugWithFor(ArrayList<String> list) {
                for (int i = 0; i < list.size(); i++)
                {
                   String str = list.get(i);
                   if (str.equalsIgnoreCase("bug"))
                   {
                      list.remove(str);
                      i--;    //важно минуснуть i, тк после удаления элементы сместятся
                   }
                }
    }
2
    public static void removeBugWithWhile(ArrayList<String> list) {
       Iterator<String> it = list.iterator();
            while (it.hasNext())
            {
               String str = it.next();
               if (str.equalsIgnoreCase("bug"))
                   it.remove(); //ремув на итератор
            }
    }
3
    public static void removeBugWithCopy(ArrayList<String> list) {
        ArrayList<String> listCopy = new ArrayList(list); //тут смысл в копии
        for (String s : listCopy){
            if (s.equalsIgnoreCase("bug")){
                list.remove(s);
            }
        }
    }

Collections
Методы	                        Описание
addAll(colls, e1, e2, e3, ..)   обавляет в коллекцию colls элементы e1, e2, e3,...
fill(list, obj)                 Заменяет в переданном списке все элементы на obj
nCopies(n, obj)                 Возвращает список, состоящий из n копий объекта obj
replaceAll(list, oldVal, newVal) Заменяет в списке list все значения oldVal на newVal
copy(dest, src)                 Копирует все элементы из списка src в список dest
reverse(list)                   Разворачивает список задом наперед
sort(list)                      Сортирует список в порядке возрастания
rotate(list, n)                 Циклично сдвигает элементы списка list на n элементов
shuffle(list)                   Случайно перемешивает элементы списка
min(colls)                      Находит минимальный элемент коллекции colls
max(colls)                      Находит максимальный элемент коллекции colls
frequency(colls, obj)           Определяет, сколько раз элемент obj встречается в коллекции colls
binarySearch(list, key)         Ищет элемент key в отсортированном списке, возвращает индекс.
disjoint(colls1, colls2)        Возвращает true, если у коллекций нет общих элементов
Многие из этих методов работают не с классами ArrayList, HashSet и HashMap, а с их интерфейсами: Collection<T>, List<T>, Map<K, V>.
Это не проблема: если метод принимает List<T>, в него всегда можно передать ArrayList<Integer>, но вот в обратную сторону присваивание не работает.

HashMap
В Java есть еще одна интересная коллекция (в широком смысле) — это коллекция Map. Точного перевода ее названия на
русский нет: чаще всего ее называют «карта», «словарь» или просто «мапа».
Ключом пары может быть что угодно, но ключ не может быть null. Ключи должны быть уникальные: одна карта не может содержать два одинаковых ключа.
HashMap<TКлюч, TЗначение> имя = new HashMap<TКлюч, TЗначение>();
void put(ТКлюч key, ТЗначение value)        Добавляет в коллекцию пару (key, value)
ТЗначение get(ТКлюч key)                    Возвращает значение по ключу
boolean containsKey(ТКлюч key)              Проверяет наличие ключа в коллекции
boolean containsValue(ТЗначение value)      Проверяет наличие значения в коллекции
ТЗначение remove(ТКлюч key)                 Удаляет элемент из коллекции
void clear() Очищает коллекцию:             удаляет все элементы
int size()                                  Возвращает количество пар элементов в коллекции
Set<ТКлюч>  keySet()                        Возвращает множество ключей коллекции
Collection<ТЗначение> values()              Возвращает множество элементов коллекции
Set<Map.Entry<TКлюч, TЗначение>> entrySet() Возвращает все значения коллекции в виде множества (Set) пар (Map.Entry).
Если при добавлении элемента выяснится, что элемент с таким ключом уже есть, старое значение ключа заменится на новое.
В коллекции HashMap есть вспомогательный класс для хранения пары элементов
Set<Entry<Ключ, Значение>> имя = map.entrySet();
Set<Map.Entry<String, Integer>> entries = map.entrySet();
можно не создавать отдельную переменную для entries, а сразу вызвать метод entrySet() внутри цикла for:
for(Map.Entry<String, Integer> pair: map.entrySet())

LinkedList
Двухсвязный список, тк каждый элемент имеет 2 ссылки: на предыдущий элемент и на следующий, это делает операции вставку через фор долгой, а через итератор быстрой
Внешне LinkedList — это такой же список, как и ArrayList. У класса LinkedList есть все те же методы, что и у класса ArrayList.
И в принципе вы всегда можете использовать LinkedList вместо ArrayList, и все будет работать.
В LinkedList вместо массива используется двусвязный список.
За счет другого внутреннего устройства у класса LinkedList — самая быстрая операция вставки элементов в середину списка.
Операция	            Метод	        ArrayList	        LinkedList
Добавление элемента	    add(value)      Быстро	            Очень быстро
Вставка элемента	    add(index, value) Медленно      	Очень медленно
Получение элемента	    get(index)      Очень быстро	    Очень медленно
Изменение элемента	    set(index, value) Очень быстро	    Очень медленно
Удаление элемента	    remove(index)   Медленно        	Очень медленно
Вставка через итератор	it.add(value)   Медленно        	Очень быстро
Удаление через итератор	it.remove()     Медленно	        Очень быстро
Никто не использует LinkedList
ArrayList стал вставлять элементы в середину списка очень быстро, сейчас у процессоров большой кэш, и обычно весь массив
попадает в такой кэш, поэтому элементы массива сдвигаются даже не в памяти, а в кэше процессора. Миллион элементов легко сдвигается за одну миллисекунду.
prev — хранит ссылку на предыдущий объект типа Node (желтый фон).
value — хранит значение – элемент списка (зеленый фон).
next — хранит ссылку на следующий объект типа Node (синий фон)

enum
конечный набор значений
Day day = Day.FRIDAY;
System.out.println(day);
На экран будет выведено: FRIDAY
Статический метод values() возвращает массив всех значений типа enum:
Day[] days = Day.values();
for (Day day: days)
   System.out.println(day);
Метод ordinal() возвращает порядковый номер константы. Вызывать его нужно не у класса enum, а у значения enum
Day newDay = Day.values()[index+2] - День недели на 2 дня позже понедельника

switch
switch(выражение)
{
   case значение1: код1;
   case значение2: код2;
   case значение3: код3;
}
Внутри скобок указывается какое-нибудь выражение или переменная. Если значение выражений равно значение1, начинает
выполняться код1, если равно значение2, начинает выполняться код2, если равно значение3 начинает выполняться код3.
Важной особенностью работы switch является то, что программа просто перепрыгивает на нужную строку (на нужный блок кода)
и затем выполняет все блоки кода до конца switch. Не только тот блок кода, который соответствует значению внутри switch, а все блоки кода до конца switch.
Если вы хотите, чтобы в каждом случае выполнялся только один блок кода, на который перепрыгнуло выполнение программы,
вам после этого блока кода нужно написать оператор break;
Если подходящий вариант не найдется, работа оператора switch завершится, и программа продолжит выполнять тот код,
который написан после фигурных скобок оператора switch.
Если ни один case вариант внутри switch не совпал со значением выражения и в switch объявлен default, будет выполнен его код
Цепочку в виде нескольких if-else лучше использовать, когда внутри условия if различные сложные выражения в каждом отдельном случае.
Не все типы можно использовать в качестве значений для case внутри оператора switch. Сейчас там можно использовать литералы таких типов:
целые типы: byte, short, int
тип char
тип String
значения любого enum-типа