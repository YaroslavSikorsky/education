// Инкапсуляция
// Полиморфизм
// Полиморфизм, часть 2
// Полиморфизм, часть 3
// Перегрузка методов - overloading
// Абстрактные классы
// Интерфейсы в Java
// Суть интерфейсов
// Разница между абстрактными классами и интерфейсами

// Отношения между классами. Наследование, композиция, агрегирование https://javarush.com/groups/posts/1967-otnoshenija-mezhdu-klassami-nasledovanie-kompozicija-i-agregirovanie-
// Принципы инкапсуляции https://javarush.com/groups/posts/1969-principih-inkapsuljacii
// Практика использования полиморфизма https://javarush.com/groups/posts/1974-praktika-ispoljhzovanija-polimorfizma
// Для чего в Java нужны интерфейсы https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih
// Разница между абстрактными классами и интерфейсами https://javarush.com/groups/posts/1985-raznica-mezhdu-abstraktnihmi-klassami-i-interfeysami



Инкапсуляция
Преимущества:
Валидное внутреннее состояние
В програмах часто возникают ситуации, когда несколько классов взаимодействуют с одним и тем же объектом.
В результате их совместной работы нарушается целостность данных внутри объекта – он уже не может продолжать нормально работать.
Поэтому объект должен следить за изменениями своих внутренних данных, а еще лучше — проводить их сам.
Правильное использование инкапсуляции гарантирует, что ни один класс не может получить прямой доступ к внутренним данным
нашего класса и, следовательно, изменить их без контроля с нашей стороны. Только через вызов методов того же класса, что и изменяемые переменные.
Лучше исходить из того, что другие программисты всегда будут использовать ваши классы самым удобным для них образом,
а не самым безопасным для вас (для вашего класса).
Контроль передаваемых аргументов
Иногда нужно контролировать аргументы, передаваемые в методы нашего класса. Например, наш класс описывает объект "человек"
и позволяет задать дату его рождения. Мы должны проверять все передаваемые данные на их соответствие логике программы и логике нашего класса.
Например, не допускать 13-й месяц, дату рождения 30 февраля и так далее
Минимизация ошибок при изменении кода классов
Когда мы меняем методы, объявленные как private, мы знаем, что нигде нет ни одного класса, который вызывал бы эти методы.
Мы можем их переделать, поменять количество параметров и их типы, и зависимый код будет работать дальше. Ну или как минимум компилироваться.
Задаем способ взаимодействия нашего объекта со сторонними объектами
Мы можем ограничить некоторые действия, допустимые с нашим объектом. Например, мы хотим, чтобы объект можно было создать только в одном экземпляре.
Даже если его создание происходит в нескольких местах проекта одновременно. И мы можем сделать это благодаря инкапсуляции.

Полиморфизм
Наследование — не панацея
Представьте, что вы для игры написали класс Корова. В нем есть много полей и методов. Объекты этого класса могут делать
разные вещи: идти, есть, спать. Еще коровы звонят в колокольчик, когда ходят. Допустим, вы реализовали в классе все до мелочей.
А тут приходит заказчик проекта и говорит, что хочет выпустить новый уровень игры, где все действия происходят в море, а главным героем будет кит.
Вы начали проектировать класс Кит и поняли, что он лишь немного отличается от класса Корова. Логика работы обоих классов
очень похожа, и вы решили использовать наследование.
Переопределение метода
К нам на помощь приходит переопределение (замена) методов. Если мы унаследовали метод, который делает не совсем то,
что нужно в нашем новом классе, мы можем заменить этот метод на другой.
Как же это делается? В нашем классе-потомке мы объявляем такой же метод, как и метод класса-родителя, который хотим изменить.
Пишем в нем новый код. И все: как будто старого метода в классе-родителе и не было.

Полиморфизм, часть 2
Главное — не в каком классе написан метод, а какой тип (класс) объекта, у которого этот метод вызван.
Приведение типов
Тут есть еще более интересный момент. Т.к. класс при наследовании получает все методы и данные класса-родителя, объект
этого класса разрешается сохранять (присваивать) в переменные класса-родителя (и родителя родителя, и т.д., вплоть до Object
Код                                         	Описание
public static void main(String[] args)          На экран будет выведена надпись: Я — белая
{
   Whale whale = new Whale();
   whale.printColor();
}
public static void main(String[] args)          На экран будет выведена надпись: Я — белая
{
   Cow cow = new Whale();
   cow.printColor();
}
public static void main(String[] args)          На экран будет выведена надпись: Whale@da435a.
{
   Object o = new Whale();
   System.out.println(o.toString());
}
Метод toString() унаследован от класса Object
Вызов метода объекта
Код	                                            Описание
public static void main(String[] args)          На экран будет выведена надпись: Я — кит
{
   Whale whale = new Whale();
   whale.printName();
}
public static void main(String[] args)          На экран будет выведена надпись: Я — кит
{
   Cow cow = new Whale();
   cow.printName();
}
Обратите внимание, что на то, какой именно метод printName() вызовется, от класса Cow или Whale, влияет не тип переменной,
а тип объекта, на который она ссылается
В переменной типа Cow сохранена ссылка на объект типа Whale, и будет вызван метод printName(), описанный в классе Whale.
Набор методов, которые можно вызвать у переменной, определяется типом переменной. А какой именно метод/какая реализация
вызовется, определяется типом/классом объекта, ссылку на который хранит переменная.

Полиморфизм, часть 3
Приведение типов
Животное котик = new Кот();
Это расширяющее приведение типа: его еще называют неявным. Мы расширили ссылку котик, и теперь она ссылается на объект типа Кот.
При таком приведении мы не сможем через ссылку котик вызвать методы, которые есть у класса Кот, но которых нет у класса Животное.
Сужающее приведение (или явное) происходит в обратную сторону:
Кот котэ = (Кот) котик;
Мы явно указали, что хотим привести ссылку, которая хранится в переменной котик (типа Животное) к типу Кот.
instanceof позволяет проверить, можно ли сохранить объект определенного типа в переменную определенного типа:
переменная instanceof Тип
Иногда бывает нужно не заменить метод родительского класса на свой при переопределении метода, а лишь немного дополнить его.
Вызов оригинального метода: super
super.метод(параметры);

Перегрузка методов - overloading
В отличие от переопределения, перегрузка — это очень простая операция. На самом деле это даже не операция над методами,
хотя иногда ее называют страшным словосочетанием — параметрический полиморфизм.
Дело в том, что все методы внутри класса должны иметь уникальные имена. Так вот, это не совсем так. Вернее, совсем не так.
Метод не должен иметь уникальное имя. Уникальным должно быть объединение имени и типов параметров этого метода. Такие объединения еще называют сигнатурами методов
Согласно принципам ООП, полиморфизм — это сокрытие различных реализаций за одним интерфейсом. А т.к. при вызове метода System.out.println(), например,
в зависимости от параметров вызываются различные методы, формально это подпадает под определение полиморфизма.
Именно поэтому разные методы с одинаковыми именами, находящиеся в одном классе, принято считать хоть и слабой, но все же формой полиморфизма.

Абстрактные классы
Общий базовый класс
Введение базового класса ChessItem помогает очень упростить код: не нужно вызывать методы каждого класса отдельно, можно легко хранить
все объекты в одной коллекции и т.п.
Более того, создавать объекты типа ChessItem не имеет смысла. Это не фигура из шахмат, а всего лишь абстракция — класс,
который мы сделали для удобства. Так работает абстракция из ООП: мы вынесли важные (общие для всех фигур) данные и методы в
базовый класс, а их различия оставили в их классах.
Абстрактные классы
1. Абстрактный класс может содержать объявление метода без его реализации. Такой метод называется абстрактным.
Вместо тела метода просто ставится точка с запятой. А перед названием метода пишется ключевое слово — abstract. Пример
public abstract class ChessItem
{
   public int x, y; // координаты
   private int value; // «ценность» фигуры
   public int getValue() // обычный метод, возвращает значение value
   {
      return value;
   }

   public abstract void draw(); // абстрактный метод. Реализация отсутствует.
}
Каждый метод без реализации помечается специальным ключевым словом abstract. Если в классе есть хоть один абстрактный метод, класс тоже помечается ключевым словом abstract.
Создавать объекты абстрактного класса нельзя. Такой код просто не скомпилируется.
Наследование от абстрактного класса
Если вы наследовали свой класс от абстрактного класса, нужно переопределить все унаследованные абстрактные методы — написать для них реализацию.
Иначе такой класс тоже придется объявить абстрактным.
Если в классе есть хотя бы один нереализованный метод, объявленный прямо в нем или унаследованный от класса-родителя, класс считается абстрактным.
И зачем это все нужно? Зачем нужны абстрактные классы? Разве нельзя вместо них использовать обычные? А вместо абстрактных методов просто писать две скобочки
в качестве тела метода – {}?
Можно. Но эти ограничения сродни модификатору private. Мы специально запрещали с помощью private прямой доступ к данным,
чтобы другие программисты и их классы пользовались только написанными нами public-методами.
То же и с абстрактным классом. Тот, кто написал этот класс, не хочет, чтобы создавались его объекты. Наоборот, он рассчитывает на то,
что от его абстрактного класса будут наследоваться и переопределяться абстрактные методы.
Преимущество этого подхода проявляется в больших проектах. Чем больше классов, тем чётче приходится очерчивать их роли.
Вы увидите преимущество этого подхода, и уже в ближайшем будущем. Все через это проходят.

Интерфейсы в Java
Знакомство с интерфейсами
Интерфейс — это дитя Абстракции и Полиморфизма. Интерфейс очень напоминает абстрактный класс, у которого все методы абстрактные.
Он объявляется так же, как и класс, только используется ключевое слово interface.
interface Кошачьи
{
   void мурчать();
   void мяукать();
   void рычать();
}
Вместо слова class пишем interface.
Содержит только абстрактные методы (слово abstract писать не нужно)
На самом деле у интерфейсов все методы – public
Наследование интерфейсов
Интерфейс может наследоваться только от интерфейсов. Зато родителей у интерфейса может быть много. Еще говорят, что в Java есть множественное наследование интерфейсов
Класс может наследоваться от нескольких интерфейсов (и только от одного класса). При этом используется ключевое слово implements
Технически между словами extends и implements нет никакой разницы: и то, и то — это наследование. Так было сделано, чтобы повысить читабельность кода.
В английском языке принято говорить, что классы наследуются (extends), а интерфейсы реализуются (implements)
Переменные
В интерфейсах нельзя объявлять переменные (хотя статические можно).
Отделение «описания методов» от их реализации.
Таким образом, мы скрываем не только различные реализации, но и сам класс, который ее содержит (везде в коде может фигурировать только интерфейс).
Это позволяет очень гибко, прямо в процессе исполнения программы, подменять одни объекты на другие, меняя поведение объекта скрытно от всех классов, которые его используют.
Множественное наследование
В Java все классы могут иметь только один класс-родитель. В других языках программирования классы часто могут иметь несколько классов-родителей.
Это очень удобно, но приносит также много проблем.
В Java пришли к компромиссу: запретили множественное наследование классов, но разрешили множественное наследование интерфейсов.
Интерфейс может иметь несколько интерфейсов-родителей. Класс может иметь несколько интерфейсов-родителей и только один класс-родитель.

Суть интерфейсов
Способности
Чтобы лучше понять преимущества интерфейсов и места их использования, нужно поговорить о более абстрактных вещах.
Класс — это, чаще всего модель какого-то конкретного объекта. Интерфейс же больше соответствует не объектам, а их способностям или ролям.
Например, такие вещи, как машина, велосипед, мотоцикл и колесо лучше всего представить в виде классов и объектов.
А такие их способности, как «могу ездить», «могу перевозить людей», «могу стоять», лучше представить в виде интерфейсов.
Роли
Весь смысл в том, что вам не нужно писать код для взаимодействия всех классов со всеми. Вам достаточно взаимодействовать с их ролями (интерфейсами).
default реализация в методах интерфейсов
Абстрактные классы могут иметь переменные и реализацию методов, но для них множественное наследование запрещено.
Интерфейсы не могут иметь переменные и реализации методов, и для них множественное наследование разрешено.
Начиная с JDK 8:
Способность	                    Абстрактные классы	            Интерфейсы
Переменные	                            ✔	                        ✖
Реализация методов	                    ✔	                        ✔
Множественное наследование	            ✖	                        ✔
В абстрактных классах перед методами без реализации нужно писать ключевое слово abstract, а перед методами с реализацией ничего добавлять не нужно.
В интерфейсах же все наоборот. Если у метода нет реализации, ничего добавлять не нужно, если же реализация есть, нужно добавить ключевое слово default.
Чтобы случайно не сломать работающие программы и библиотеки, было решено, что реализация методов в интерфейсах получит самый низкий приоритет при наследовании.

Разница между абстрактными классами и интерфейсами
Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса состояние есть: он описывает и то, и другое
Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую связь. В то же время, один и тот же интерфейс могут реализовать классы,
у которых вообще нет ничего общего
Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только от одного класса.