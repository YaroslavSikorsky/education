// Загрузка классов
// Статистические переменные
// Статистические методы
// Статистические классы

// 8 частых ошибок начинающих программистов https://javarush.com/groups/posts/1964-8-chastihkh-oshibok-nachinajujshikh-programmistov

// Класс является объектом - А, [10.02.2023 22:40]: ну это лучше забыть, класс это класс, у каждого клсса есть объект с метаинформацией



Загрузка классов
При загрузке класса в память создаются три специальных «объекта» (1, 2, 3)
0. Файл с кодом хранится на диске в виде файла с расширением «.class». Он содержит информацию о классе, его полях и методах,
а также код методов, скомпилированный в байт-код.
1. Когда Java-машина загружает класс в память, она компилирует его байт-код в машинный код с учетом процессора компьютера
и его операционной системы. Доступ к этому машинному коду есть только у Java-машины: у нас как у Java-программистов его нет.
2. Java-машина создает некий объект, который содержит все статические переменные и методы класса. Доступ к этому «объекту»
у вас есть по имени класса
3. Когда Java-машина загружает код класса в память, она создает специальный объект типа java.lang.Class, в котором хранится
информация о загруженном классе: его имя, имена методов, имена и типы полей и т.п.
Получить объект класса можно у любого типа с помощью команды вида:
Class имя = ИмяКласса.class;
Class a = String.class; Получаем объект типа Class с информацией о классе String
Class d = int.class; Получаем объект типа Class с информацией о типе int
Ссылку на объект с описанием класса можно получить и у объекта: для этого у каждого объекта есть метод getClass(), унаследованный от класса Object.
Class a = "Привет".getClass(); Тот же объект, что и String.class
Class b = new Integer().getClass(); Тот же объект, что и Integer.class

Статические переменные
Когда класс загружается в память, для него сразу создается статический объект класса. Этот объект хранит статические переменные класса
(статические поля класса). Статический объект класса существует, даже если не был создан ни один обычный объект класса.
Обычные переменные класса привязаны к объектам своего класса (экземплярам класса), статические переменные — к статическому объекту класса.
Когда мы описываем переменные в классе, мы указываем, будут ли эти переменные созданы всего один раз или же нужно создавать их копии для каждого объекта. По умолчанию создаётся новая копия переменной для каждого объекта.
Статическая (static) же переменная привязана к статическому объекту класса и всегда существует в единственном экземпляре.

Статические методы
не имеют доступа к нестатическим переменным класса.
Статический объект класса существует, даже если не был создан ни один обычный объект класса.
Обычные переменные класса привязаны к объектам своего класса (экземплярам класса), статические переменные — к статическому объекту класса.
Если экземпляров класса несколько, в каждом из них существует своя копия нестатических (обычных) переменных класса.
Статические переменные класса всегда находятся внутри статического объекта класса и существуют только в одном экземпляре.
Обычные методы привязаны к объектам (экземплярам) класса и могут обращаться к обычным-переменным класса (а также к статическим переменным и методам).
Статические же методы привязаны к статическому объекту класса и могут обращаться только к статическим переменным и/или другим статическим методам класса.
При вызове обычного метода в него передается скрытый параметр — объект, у которого его вызывали. Этот параметр имеет имя this.
Именно этот скрытый параметр — ссылка на объект, у которого вызвали метод — и отличает обычные методы от статических.
У статических методов такого скрытого параметра нет, поэтому внутри статических методов нельзя пользоваться ключевым словом this,
и из статического метода нельзя вызвать нестатический: ссылку на экземпляр класса попросту неоткуда взять.
Статические методы можно вызывать откуда угодно — из любого места программы. А значит, их можно вызывать и из статических методов, и из обычных.
Внутренние классы
Внутренние классы бывают статические и нестатические. Статические классы еще называют вложенными (static nested class),
нестатические просто называют внутренними классами (inner class).
Статические вложенные классы можно использовать вне своего родительского класса. Если у такого класса стоит модификатор
доступа public, его можно использовать в любом месте программы. Такие классы фактически ничем не отличаются от любого обычного
класса. Хотя есть пара отличий.
Если вы хотите обратиться к статическому вложенному классу не из его класса-родителя, а из другого места в программе,
вам нужно будет указать имя класса: оно состоит из имени класса родителя и имени вложенного класса. Общий вид этого имени такой:
КлассРодитель.ВложенныйКласс
Особенности статических классов
Статические внутренние классы меньше всего стоило бы называть статическими. Они ведут себя точно так же, как обычные классы.
Никаких ограничений на обращение к ним из нестатических методов нет.
Если вы работаете с внутренним статическим классом внутри его класса-родителя, вообще не заметите никакой разницы с тем,
если бы этот внутренний класс был бы самым обычным классом (не вложенным и не статическим).
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner(); //внутренний
Outer.Nested nested = new Outer.Nested(); //вложенный статический
В файле с расширением java всегда должен быть класс, имя которого совпадает с именем файла, и у него есть модификатор public
В одном файле может быть только один публичный класс. В файле могут быть объявлены еще классы, но они должны быть или
внутренними классами публичного класса, или же не иметь модификатора public
String
Пул строк (String Pool) — это множество строк в кучи (Java Heap Memory). Мы знаем, что String — особый класс в java,
с помощью которого мы можем создавать строковые объекты.
Сам строковый пул возможен только потому, что строки в Java неизменные. Также пул строк позволяет сохранить память в
Java Runtime, хотя это и требует больше времени на создание самой строки.
Часто программисты-новички забывают, что все объекты класса являются неизменяемыми (immutable), и все методы класса String
возвращают новый объект, а текущий объект никогда не меняется.
String s = "Привет";
String result = s.toUpperCase(); // преобразование строки к верхнему регистру, необходимо создание новой строки
У коллекции, начиная с Java 8, появился метод removeIf(), в который можно передать правило (лямбда-функцию), указывающее, какие элементы нужно удалить.
ArrayList<Integer> list = new ArrayList<Integer>();
Collections.addAll(list, 0, -5, -7, -12, 5, 15);
list.removeIf( x-> x<0 );
ИЛИ
for (int i = 0; i < students.size(); i++) {
            if (students.get(i).equals(excludedStudent)) {
                students.remove(i);
            }
        }
Когда интерфейс наследуется от интерфейса, нужно использовать ключевое слово extends.
stack trace, простыми словами, трассировка стека – это список методов, которые были вызваны до момента, когда в приложении произошло исключение.

