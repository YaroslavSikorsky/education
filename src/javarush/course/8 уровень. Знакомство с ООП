// Инкапсуляция
// Полиморфизм
// Полиморфизм, часть 2
// Полиморфизм, часть 3
// Перегрузка методов - overloading





Инкапсуляция
Преимущества:
Валидное внутреннее состояние
В програмах часто возникают ситуации, когда несколько классов взаимодействуют с одним и тем же объектом.
В результате их совместной работы нарушается целостность данных внутри объекта – он уже не может продолжать нормально работать.
Поэтому объект должен следить за изменениями своих внутренних данных, а еще лучше — проводить их сам.
Правильное использование инкапсуляции гарантирует, что ни один класс не может получить прямой доступ к внутренним данным
нашего класса и, следовательно, изменить их без контроля с нашей стороны. Только через вызов методов того же класса, что и изменяемые переменные.
Лучше исходить из того, что другие программисты всегда будут использовать ваши классы самым удобным для них образом,
а не самым безопасным для вас (для вашего класса).
Контроль передаваемых аргументов
Иногда нужно контролировать аргументы, передаваемые в методы нашего класса. Например, наш класс описывает объект "человек"
и позволяет задать дату его рождения. Мы должны проверять все передаваемые данные на их соответствие логике программы и логике нашего класса.
Например, не допускать 13-й месяц, дату рождения 30 февраля и так далее
Минимизация ошибок при изменении кода классов
Когда мы меняем методы, объявленные как private, мы знаем, что нигде нет ни одного класса, который вызывал бы эти методы.
Мы можем их переделать, поменять количество параметров и их типы, и зависимый код будет работать дальше. Ну или как минимум компилироваться.
Задаем способ взаимодействия нашего объекта со сторонними объектами
Мы можем ограничить некоторые действия, допустимые с нашим объектом. Например, мы хотим, чтобы объект можно было создать только в одном экземпляре.
Даже если его создание происходит в нескольких местах проекта одновременно. И мы можем сделать это благодаря инкапсуляции.

Полиморфизм
Наследование — не панацея
Представьте, что вы для игры написали класс Корова. В нем есть много полей и методов. Объекты этого класса могут делать
разные вещи: идти, есть, спать. Еще коровы звонят в колокольчик, когда ходят. Допустим, вы реализовали в классе все до мелочей.
А тут приходит заказчик проекта и говорит, что хочет выпустить новый уровень игры, где все действия происходят в море, а главным героем будет кит.
Вы начали проектировать класс Кит и поняли, что он лишь немного отличается от класса Корова. Логика работы обоих классов
очень похожа, и вы решили использовать наследование.
Переопределение метода
К нам на помощь приходит переопределение (замена) методов. Если мы унаследовали метод, который делает не совсем то,
что нужно в нашем новом классе, мы можем заменить этот метод на другой.
Как же это делается? В нашем классе-потомке мы объявляем такой же метод, как и метод класса-родителя, который хотим изменить.
Пишем в нем новый код. И все: как будто старого метода в классе-родителе и не было.

Полиморфизм, часть 2
Главное — не в каком классе написан метод, а какой тип (класс) объекта, у которого этот метод вызван.
Приведение типов
Тут есть еще более интересный момент. Т.к. класс при наследовании получает все методы и данные класса-родителя, объект
этого класса разрешается сохранять (присваивать) в переменные класса-родителя (и родителя родителя, и т.д., вплоть до Object
Код                                         	Описание
public static void main(String[] args)          На экран будет выведена надпись: Я — белая
{
   Whale whale = new Whale();
   whale.printColor();
}

public static void main(String[] args)          На экран будет выведена надпись: Я — белая
{
   Cow cow = new Whale();
   cow.printColor();
}

public static void main(String[] args)          На экран будет выведена надпись: Whale@da435a.
{
   Object o = new Whale();
   System.out.println(o.toString());
}
Метод toString() унаследован от класса Object
Вызов метода объекта
Код	                                            Описание
public static void main(String[] args)          На экран будет выведена надпись: Я — кит
{
   Whale whale = new Whale();
   whale.printName();
}
public static void main(String[] args)          На экран будет выведена надпись: Я — кит
{
   Cow cow = new Whale();
   cow.printName();
}
Обратите внимание, что на то, какой именно метод printName() вызовется, от класса Cow или Whale, влияет не тип переменной,
а тип объекта, на который она ссылается
В переменной типа Cow сохранена ссылка на объект типа Whale, и будет вызван метод printName(), описанный в классе Whale.
Набор методов, которые можно вызвать у переменной, определяется типом переменной. А какой именно метод/какая реализация
вызовется, определяется типом/классом объекта, ссылку на который хранит переменная.

Полиморфизм, часть 3
Приведение типов
Животное котик = new Кот();
Это расширяющее приведение типа: его еще называют неявным. Мы расширили ссылку котик, и теперь она ссылается на объект типа Кот.
При таком приведении мы не сможем через ссылку котик вызвать методы, которые есть у класса Кот, но которых нет у класса Животное.
Сужающее приведение (или явное) происходит в обратную сторону:
Кот котэ = (Кот) котик;
Мы явно указали, что хотим привести ссылку, которая хранится в переменной котик (типа Животное) к типу Кот.
instanceof позволяет проверить, можно ли сохранить объект определенного типа в переменную определенного типа:
переменная instanceof Тип
Иногда бывает нужно не заменить метод родительского класса на свой при переопределении метода, а лишь немного дополнить его.
Вызов оригинального метода: super
super.метод(параметры);

Перегрузка методов - overloading
В отличие от переопределения, перегрузка — это очень простая операция. На самом деле это даже не операция над методами,
хотя иногда ее называют страшным словосочетанием — параметрический полиморфизм.
Дело в том, что все методы внутри класса должны иметь уникальные имена. Так вот, это не совсем так. Вернее, совсем не так.
Метод не должен иметь уникальное имя. Уникальным должно быть объединение имени и типов параметров этого метода. Такие объединения еще называют сигнатурами методов
Согласно принципам ООП, полиморфизм — это сокрытие различных реализаций за одним интерфейсом. А т.к. при вызове метода System.out.println(), например,
в зависимости от параметров вызываются различные методы, формально это подпадает под определение полиморфизма.
Именно поэтому разные методы с одинаковыми именами, находящиеся в одном классе, принято считать хоть и слабой, но все же формой полиморфизма.