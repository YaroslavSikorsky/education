// Потоки ввода/вывода
// Потоки для ввода/вывода файлов
// InputStream/OutputStream
// BufferedInputStream
// Свой поток — обертка на System.in

// Для чего нужен класс PrintStream https://javarush.com/groups/posts/2138-dlja-chego-nuzhen-klass-printstream
// Ввод-вывод в Java. Классы FileInputStream, FileOutputStream, BufferedInputStream
https://javarush.com/groups/posts/2020-vvod-vihvod-v-java-klassih-fileinputstream-fileoutputstream-bufferedinputstream



Потоки ввода/вывода
Потоки делятся по направлению: потоки ввода и потоки вывода.
Потоки делятся по типу данных: работают с байтами или работают с символами.
X                           Поток ввода	                    Поток вывода
Работает с байтами	        InputStream	                    OutputStream
Работает с символами	    Reader	                        Writer
Если объект реализует интерфейс InputStream, значит, он поддерживает последовательное чтение из него байт (byte).
Если объект реализует интерфейс OutputStream, значит, он поддерживает последовательную запись в него байт (byte).
Если объект реализует интерфейс Reader, значит, он поддерживает последовательное чтение из него символов (char).
Если объект реализует интерфейс Writer, значит, он поддерживает последовательную запись в него символов (char).
Если класс реализует интерфейс OutputStream – он позволяет записывать в него байты. Почти так же, как ты выводишь данные на консоль.
Что он будет с этими данными делать – его задача. В «конструкторе» важно не назначение отдельного элемента, а насколько классные вещи мы можем собрать,
благодаря многообразию существующих элементов.

Потоки для ввода/вывода файлов
FileInputStream
Для чтений и записи файлов есть два класса:  FileInputStream и FileOutputStream. Как ты уже, наверное, догадался,
FileInputStream позволяет последовательно читать из файла байты, а FileOutputStream – записывать в файл байты
FileInputStream(String fileName);  - Это конструктор. Позволяет указать имя файла на диске, из которого созданный объект будет читать данные.
int read();                        - Метод читает один байт из файла и возвращает его как результат. Тип результата расширяется до int.
int available();                   - Метод возвращает количество непрочитанных (доступных) байт.
void close();                      - Метод «закрывает» поток, вызывается после окончания работы с потоком.
Объект выполняет служебные операции, связанные с закрытием файла на диске и т.д. Из потока больше нельзя читать данные.
Посчитаем сумму всех байт в файле на диске. Вот как будет выглядеть этот код:
public static void main(String[] args) throws Exception {
 //создаем объект FileInputStream, привязанный к файлу «c:/data.txt».
 FileInputStream inputStream = new FileInputStream("c:/data.txt");
 long sum = 0;
 while (inputStream.available() > 0){ //пока остались непрочитанные байты
  int data = inputStream.read(); //прочитать очередной байт
  sum += data; //добавить его к общей сумме
 }
 inputStream.close(); // закрываем поток
 System.out.println(sum); //выводим сумму на экран.
}
FileOutputStream
ileOutputStream (String fileName);  — это конструктор. Позволяет указать имя файла на диске, в который созданный объект будет писать данные.
void write(int data);               — метод записывает очередной байт, обрезая переменную data до одного байта.
void flush();                       — часто данные для записи сначала собираются в большие блоки в памяти, а потом только пишутся на диск.
Команда flush требует немедленно записать всю несохраненную информацию на диск.
void close();                       — метод «закрывает» поток, вызывается после окончания работы с потоком.
Объект выполняет служебные операции, связанные с закрытием файла на диске и т.д.
Вот как можно скопировать файл на диске, пользуясь этими классами:
public static void main(String[] args) throws Exception {
 //Создаем поток-чтения-байт-из-файла
 FileInputStream inputStream = new FileInputStream("c:/data.txt");
 // Создаем поток-записи-байт-в-файл
 FileOutputStream outputStream = new FileOutputStream("c:/result.txt");
 while (inputStream.available() > 0) { //пока есть еще непрочитанные байты
  int data = inputStream.read(); // прочитать очередной байт в переменную data
  outputStream.write(data); // и записать его во второй поток
 }
 inputStream.close(); //закрываем оба потока. Они больше не нужны.
 outputStream.close();
}

InputStream/OutputStream
На самом деле, то первое объяснение было немного упрощенным. Это не интерфейсы, а абстрактные классы, и они даже имеют по паре реализованных методов.
Давай посмотрим, какие методы у них есть:
Методы класса InputStream	        Что метод делает
int read(byte[] buff);              — метод сразу читает блок байт в буфер (массив байт), пока буфер не заполнится или не закончатся байты там, откуда он их читает.
Метод возвращает количество реально прочитанных байт (оно может быть меньше длины массива)
int read();                         — метод читает один байт и возвращает его как результат. Результат расширяется до int, для красоты. Если все байты уже прочитаны, метод вернет «-1».
int available();                    — метод возвращает количество непрочитанных (доступных) байт.
void close();                       — метод «закрывает» поток – вызывается после окончания работы с потоком.
Объект выполняет служебные операции, связанные с закрытием файла на диске и т.д.
Из потока больше нельзя читать данные.
Методы OutputStream	Что метод делает
void write(int c);                  — метод записывает один байт информации. Тип int сужается до byte, лишняя часть просто отбрасывается.
void write(byte[] buff);            — метод записывает блок байт.
void write(byte[] buff, int from, int count);   — метод записывает часть блока байт. Используется в случаях, когда есть вероятность, что блок данных был заполнен не целиком
void flush();                       — если есть данные, которые хранятся где-то внутри и еще не записаны, то они записываются.
void close();                       — метод «закрывает» поток – вызывается после окончания работы с потоком.
Объект выполняет служебные операции, связанные с закрытием файла на диске и т.д.В поток больше нельзя писать данные, flush при этом вызывается автоматически.
public static void main(String[] args) throws Exception {
 //Создаем поток-чтения-байт-из-файла
 FileInputStream inputStream = new FileInputStream("c:/data.txt");
 // Создаем поток-записи-байт-в-файл
 FileOutputStream outputStream = new FileOutputStream("c:/result.txt");
  byte[] buffer = new byte[1000];
 while (inputStream.available() > 0){ //пока есть еще непрочитанные байты
   // прочитать очередной блок байт в переменную buffer и реальное количество в count
  int count = inputStream.read(buffer);
  outputStream.write(buffer, 0, count); //записать блок(часть блока) во второй поток
 }
 inputStream.close(); //закрываем оба потока. Они больше не нужны.
 outputStream.close();
}
Когда мы читаем самый последний блок данных в файле, может оказаться, что байт осталось не 1000, а, скажем, 328.
Тогда и при записи нужно указать, что записать не весь блок, а только его первые 328 байт.
Метод read при чтении последнего блока вернет значение равное количеству реально прочитанных байт. Для всех чтений – 1000, а для последнего блока – 328.
Поэтому при записи блока мы указываем, что нужно записать не все байты из буфера, а только 328 (т.е. значение, хранимое в переменной count).

BufferedInputStream
Паттерн проектирования «Обёртка» (Wrapper или Decorator) – это довольно простой и удобный механизм расширения функциональности объектов.
Если мы хотим «обернуть» вызовы методов какого-то объекта своим кодом, то нам нужно:
1 Создать свой класс-обертку и унаследоваться от класса/интерфейса, для которого делаем обертку.
2 Передать оборачиваемый объект в конструктор нашего класса.
3 Переопределить все методы в нашем новом классе, и вызвать в них методы оборачиваемого объекта.
4 Внести свои изменения «по вкусу»: менять результаты вызовов, параметры или делать что-то еще.
В примере ниже мы перехватываем вызов метода getName у объекта cat и немного меняем его результат (примера нет).
Т.е. мы подменяем каждый оригинальный объект на объект-обертку, в который уже передаем ссылку на оригинальный объект.
Все вызовы методов у обертки идут к оригинальному объекту.
— Еще я расскажу тебе про «мешок сахара», но это не паттерн, а метафора. Метафора к слову буфер и буферизация. Что же такое буферизация и зачем она нужна?
Допустим, сегодня очередь Риши готовить, а ты ему помогаешь. Риши еще нет, а я хочу выпить чай и прошу тебя принести мне ложечку сахара.
Ты пошел в подвал, там стоит мешок с сахаром. Ты можешь принести мне целый мешок, но мешок мне не нужен. Мне нужна только одна ложка.
Тогда ты, как хороший робот, набрал одну ложку и принес мне. Я добавила ее в чай, но все равно не очень сладко. И я попросила у тебя еще одну.
Ты опять сходил в подвал и принес еще ложку. Потом пришла Элли, и я попросила тебя принести сахара для нее… Это все слишком долго и неэффективно.
Пришел Риша, посмотрел на все это и попросил тебя принести ему полную сахарницу сахара. Потом я и Элли стали просить сахар у Риши. Он просто давал его нам из сахарницы, и все.
То, что произошло после появления Риши называется буферизацией, а сахарница – это буфер. Благодаря буферизации «клиенты» могут читать данные из буфера маленькими порциями,
а буфер, чтобы сэкономить время и силы, читает их из источника большими порциями.
Класс BufferedInputStream – классический представитель обертки-буфера. Он – класс-обертка над InputStream. При чтении данных из него, он читает их из оригинального InputStream’а большими порциями в буфер, а потом отдает из буфера потихоньку.

// Свой поток — обертка на System.in
System.in – это простая статическая переменная типа InputStream, но присвоить ей новое значение просто так нельзя. Зато можно воспользоваться методом System.setIn().
Для начала нам нужно создать буфер, потом положить в него какие-то значения. Затем завернуть в класс, который умеет из этого буфера читать данные по протоколу InputStream.
public static void main(String[] args) throws IOException{
 //кладем данные в строку
 StringBuilder sb = new StringBuilder();
 sb.append("Lena").append('\n');
 sb.append("Olya").append('\n');
 sb.append("Anya").append('\n');
 String data = sb.toString();
 //Оборачиваем строку в класс ByteArrayInputStream
 InputStream is = new ByteArrayInputStream(data.getBytes());
 //подменяем in
 System.setIn(is);
 //вызываем обычный метод, который не подозревает о наших манипуляциях
 readAndPrintLine();
}
public static void readAndPrintLine() throws IOException{
 InputStreamReader isr = new InputStreamReader(System.in);
 BufferedReader reader = new BufferedReader(isr);
 while (true) {
  String line = reader.readLine();
  if (line == null) break;
  System.out.println(line);
 }
 reader.close();
 isr.close();
}