// Полиморфизм и переопределение
// Перегрузка методов
// Абстрактные классы
// Интерфейсы
// Интерфейсы — это больше чем интерфейсы — это поведение

// Практика использования полиморфизма https://javarush.com/groups/posts/1974-praktika-ispoljhzovanija-polimorfizma
// Механизм переопределения методов или Override в Java https://javarush.com/groups/posts/1975-kak-ustroen-mekhanizm-pereopredelenija-metodov-
// Интерфейсы в Java https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih
// Дефолтные методы в интерфейсах https://javarush.com/groups/posts/1984-defoltnihe-metodih-v-interfeysakh
/ Абстрактные классы в Java на конкретных примерах https://javarush.com/groups/posts/1973-abstraktnihe-klassih-v-java-na-konkretnihkh-primerakh



Полиморфизм и переопределение
В нашем классе-потомке мы объявляем такой же метод, как и метод класса родителя, который хотим изменить.
Главное, не в каком классе написан метод, а какой тип (класс) объекта, у которого этот метод вызван.
Наследовать и переопределять можно только нестатические методы. Статические методы не наследуются и, следовательно, не переопределяются.
Cow cow = new Whale();
cow.printName();
На экран будет выведена надпись: Я – кит.
Какой именно метод printName вызовется, от класса Cow или Whale, влияет не тип переменной, а тип – объекта, на который она ссылается.
В переменной типа Cow сохранена ссылка на объект типа Whale, и будет вызван метод printName, описанный в классе Whale.
Приведение типов
Тут есть еще более интересный момент. Т.к. класс при наследовании получает все методы и данные класса родителя,
то объект этого класса разрешается сохранять (присваивать) в переменные класса родителя (и родителя родителя, и т.д., вплоть до Object).
Набор методов, которые можно вызвать у переменной, определяется типом переменной. А какой именно метод/какая реализация вызовется,
определяется типом/классом объекта, ссылку на который хранит переменная
Расширение типа
Для ссылочных типов, т.е. классов, приведение типов работает не так, как для примитивных типов. Хотя у ссылочных типов
тоже есть расширение и сужение типа. Пример:
Cow cow = new Whale();
Классическое расширение типа. Теперь кита обобщили (расширили) до коровы, но у объекта типа Whale можно вызывать только методы, описанные в классе Cow.
Компилятор разрешит вызвать у переменной cow только те методы, которые есть у ее типа — класса Cow.
Сужение типа
Классическое сужение типа с проверкой. Переменная cow типа Cow, хранит ссылку на объект класса Whale.
Мы проверяем, что это так и есть, и затем выполняем операцию преобразования (сужения) типа. Или как ее еще называют – downcast.
Ссылочное сужение типа можно провести и без проверки типа объекта.
Вызов оригинального метода
Иногда необходимл не заменить унаследованный метод на свой при переопределении метода, а лишь немного дополнить его.
В этом случае очень хочется исполнить в новом методе свой код и вызвать этот же метод, но базового класса.
И такая возможность в Java есть. Делается это так: super.method().

Перегрузка методов
Перегрузка – параметрический полиморфизм.
Уникальным должно быть объединение из имени и типов параметров этого метода.

Абстрактные классы
1 Абстрактный класс может содержать объявление метода без его реализации. Такой метод называется абстрактным.
2 Абстрактный метод помечается специальным ключевым словом abstract.
Если в классе есть хоть один абстрактный метод, класс тоже помечается ключевым словом abstract.
3 Создавать объекты абстрактного класса нельзя. Такой код просто не скомпилируется.
4 Если ты наследовал свой класс от абстрактного класса, то нужно переопределить все унаследованные абстрактные методы — написать для них реализацию.
Иначе такой класс тоже придется объявить абстрактным. Если в классе есть хотя-бы один нереализованный метод, объявленный прямо в нем или унаследованный от класса-родителя, то класс считается абстрактным

Интерфейсы
Интерфейс очень напоминает абстрактный класс, у которого все методы абстрактные. Он объявляется так же, как и класс,
только используется ключевое слово interface
1 Вместо слова class пишем interface.
2 Содержит только абстрактные методы (слово abstract писать не нужно).
3 У интерфейсов все методы — public.
Интерфейс может наследоваться только от интерфейсов.
Интерфейсов-родителей может быть много.

У интерфейсов есть два сильных преимущества по сравнению с классами:
1 Отделение «описания методов» от их реализации.
Один и тот же интерфейс могут реализовывать (наследовать) различные классы. И у каждого может быть свое собственное поведение.
Так же как ArrayList и LinkedList – это две различные реализации интерфейса List.
Таким образом, мы скрываем не только различные реализации, но и даже сам класс, который ее содержит (везде в коде может фигурировать только интерфейс).
Это позволяет очень гибко, прямо в процессе исполнения программы, подменять одни объекты на другие, меняя поведение объекта скрытно от всех классов,
которые его используют
2 Множественное наследование
В Java все классы могут иметь только одного класса-родителя. В других языках программирования, классы часто могут иметь несколько классов-родителей.
Это очень удобно, но приносит так же много проблем.
В Java пришли к компромиссу – запретили множественное наследование классов, но разрешили множественное наследование интерфейсов.
Интерфейс может иметь несколько интерфейсов-родителей. Класс может иметь несколько интерфейсов-родителей и только один класс-родитель.

Интерфейсы — это больше чем интерфейсы — это поведение
Класс – это, чаще всего модель какого-то конкретного объекта. Интерфейс же больше соответствует не объектам, а их способностям или ролям.
Например, такие вещи, как машина, велосипед, мотоцикл и колесо лучше всего представить в виде классов и объектов.
А такие их способности как «могу ездить», «могу перевозить людей», «могу стоять» — лучше представить в виде интерфейсов.
Очень часто в программе тысячи объектов, сотни классов и всего пара десятков интерфейсов – ролей. Ролей мало, а их комбинаций – классов – очень много.
Весь смысл в том, что тебе не нужно писать код для взаимодействия со всеми классами. Тебе достаточно взаимодействовать с их ролями (интерфейсами).