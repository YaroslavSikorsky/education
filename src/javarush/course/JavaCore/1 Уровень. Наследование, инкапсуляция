// ООП — основные принципы
// Наследование. Преимущество наследования
// Инкапсуляция

// Принципы ООП https://javarush.com/groups/posts/principy-oop
// Принципы ООП https://javarush.com/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija
// Отношения между классами. Наследование, композиция и агрегирование
https://javarush.com/groups/posts/1967-otnoshenija-mezhdu-klassami-nasledovanie-kompozicija-i-agregirovanie-
// Принципы инкапсуляции в Java https://javarush.com/groups/posts/1969-principih-inkapsuljacii



ООП — основные принципы
Абстракция — это правильное разделение программы на объекты.
Обычно любую большую программу можно десятками способов представить в виде взаимодействующих объектов.
Абстракция позволяет отобрать главные характеристики и опустить второстепенные.
Инкапсуляция
Цель инкапсуляции – улучшить качество взаимодействия вещей за счет их упрощения.
А лучший способ упростить что-то – это скрыть все сложное от посторонних глаз. Например, если тебя посадят в кабину Боинга, ты не сразу разберешься,
как им управлять: с другой стороны, для пассажиров самолета все выглядит проще: купил билет, сел в самолет, взлетели и приземлились.
Инкапсуляция – это «сокрытие реализации».
Класс может содержать сотни методов и реализовывать очень сложное поведение в различных ситуациях. Но мы можем скрыть от посторонних глаз все его методы
(пометить модификатором private), а для взаимодействия с другими классами оставить всего пару-тройку методов (пометить их модификатором public).
Тогда все остальные классы нашей программы будут видеть в этом классе всего три метода, и будут вызывать именно их. А все сложности будут скрыты внутри класса,
как кабина пилотов от счастливых пассажиров.
Наследование
У наследования есть две стороны. Сторона программирования и сторона реальной жизни. С точки зрения программирования, наследование –
это специальное отношение между двумя классами. Но гораздо интереснее, что же такое наследование с точки зрения реальной жизни.
Если бы нам понадобилось что-то создать в реальной жизни, то у нас есть два решения:
1 создать нужную нам вещь с нуля, потратив кучу времени и сил.
2 создать нужную нам вещь на основе уже существующей.
Наиболее оптимальная стратегия выглядит так: берем существующее хорошее решение, немного его дорабатываем, подгоняем под свои нужды и используем.
Если мы проследим историю возникновения человека, то окажется, что с момента зарождения жизни на планете прошли миллиарды лет. А если представить,
что человек возник из обезьяны (на основе обезьяны), то прошла всего пара миллионов лет. Создание с нуля – дольше.
В программировании тоже есть возможность создавать один класс на основе другого. Новый класс становится потомком (наследником) уже существующего.
Это очень выгодно, когда есть класс, который содержит 80%-90% нужных нам данных и методов. Мы просто объявляем подходящий класс родителем нашего нового класса,
тогда в новом классе автоматически появляются все данные и методы класса-родителя.
Полиморфизм
Описывает ситуацию, когда за одним интерфейсом скрываются разные реализации.
Если постараться поискать его аналоги в реальной жизни, то одним из таких аналогов будет процесс управления машиной.
Если человек может управлять грузовиком, то его можно посадить и за руль скорой, и за руль спорткара. Человек может управлять машиной вне зависимости
от того, что это за машина, потому что все они имеют одинаковый интерфейс управления: руль, педали и рычаг коробки передач.
Внутреннее устройство машин разное, но все они имеют одинаковый интерфейс управления (управлять).
Если вернуться к программированию, то полиморфизм позволяет единообразно обращаться к объектам различных классов (обычно имеющих общего предка) –
вещь, которую трудно переоценить. Ценность его тем выше, чем больше программа.
ООП – это принципы. Внутренние законы. Каждый из них нас в чем-то ограничивает, давая взамен большие преимущества, когда программа вырастает
до больших размеров. Четыре принципа ООП – это как четыре ножки стула. Убери хотя бы одну, и вся система станет неустойчивой.
?Выбор структуры отделов и способа их взаимодействия – это «принцип Абстракции». В программировании он используется для определения,
на какие части лучше разбить программу, и как эти части должны взаимодействовать. Данный принцип также можно применять к разделению полученных частей,
пока мы не разобьем программу на отдельные классы.
Сокрытие внутренней структуры этих частей, и жёсткие ограничения на взаимодействие с другими частями – это Инкапсуляция
Инкапсуляция + Абстракция – это краеугольные камни ООП?

Наследование. Преимущество наследования
Предположим, что ты волшебник и хочешь создать летающую лошадь. С одной стороны, ты бы мог попробовать наколдовать пегаса. Но т.к. пегасов в природе не существует,
это будет очень непросто. Придется очень много делать самому. Куда проще взять лошадь и приколдовать ей крылья.

Инкапсуляция
4 преимущества инкапсуляции:
1 Валидное внутреннее состояние.
В программах часто возникают ситуации, когда несколько классов, взаимодействуют с одним и тем же объектом. В результате их совместной работы
нарушается целостность данных внутри объекта — объект уже не может продолжить нормально работать.
Поэтому объект должен следить за изменениями своих внутренних данных, а еще лучше – проводить их сам.
Если мы не хотим, чтобы какая-то переменная класса менялась другими классами, мы объявляем ее private, и тогда только методы её же класса
смогут получить к ней доступ. Если мы хотим, чтобы значения переменных можно было только читать, но не изменять, тогда нужно добавить public getter
для нужных переменных.
Например, мы хотим, чтобы все могли узнать количество элементов в нашей коллекции, но никто не мог его поменять без нашего разрешения.
Тогда мы объявляем переменную private int count и метод public getCount().
Правильное использование инкапсуляции гарантирует, что ни один класс не может получить прямой доступ к внутренним данным нашего класса и,
следовательно, изменить их без контроля с нашей стороны. Только через вызов методов того же класса, что и изменяемые переменные.
Лучше исходить из того, что другие программисты всегда будут использовать твои классы самым удобным для них образом, а не самым безопасным для тебя
 (для твоего класса). Отсюда и ошибки, и попытки заранее избавиться от них.
2 Контроль передаваемых аргументов
Иногда нужно контролировать аргументы, передаваемые в методы нашего класса. Например, наш класс описывает объект «человек» и позволяет задать дату его рождения.
Мы должны проверять все передаваемые данные на их соответствие логике программы и логике нашего класса. Например, не допускать 13-й месяц,
дату рождения 30 февраля и так далее.
— А зачем кому-то указывать в дате рождения 30 февраля?
— Во-первых – это может быть ошибка ввода данных от пользователя.
Во-вторых, прежде чем программа будет работать как часы, в ней будет много ошибок. Например, возможна такая ситуация.
Программист пишет программу для определения людей, у которых день рождения послезавтра. Например, сегодня 3 марта. Программа добавляет к текущему дню
месяца число 2 и ищет всех, кто родился 5 марта. Вроде бы все верно.
Вот только, когда наступит 30 марта программа не найдет никого, т.к. в календаре нет 32 марта. В программе становится гораздо меньше ошибок,
когда в методы добавляют проверку переданных данных.
Например, в ArrayList, есть проверка индекса в методах get и set: index больше или равен нулю и меньше длины массива.
Плюс в нем кидается исключение, если в массиве нет элемента с таким индексом.
3 Минимизация ошибок при изменении кода классов
Представим, что мы написали один очень полезный класс, когда участвовали в большом проекте. Он так всем понравился, что другие программисты
начали использовать его в сотнях мест в своем коде.
Класс оказался настолько полезен, что ты решил его улучшить. Но если ты удалишь какие-то методы этого класса, то код десятков людей перестанет
компилироваться. Им придется срочно все переделывать. И чем больше переделок, тем больше ошибок. Ты поломаешь кучу сборок, и тебя будут ненавидеть.
А когда мы меняем методы, объявленные как private, мы знаем, что нигде нет ни одного класса, который вызывал бы эти методы. Мы можем их переделать,
поменять количество параметров и их типы, и зависимый код будет работать дальше. Ну, или как минимум, компилироваться.
4 Задаем способ взаимодействия нашего объекта со сторонними объектами
Мы можем ограничить некоторые действия, допустимые с нашим объектом. Например, мы хотим, чтобы объект можно было создать только в одном экземпляре.
Даже если его создание происходит в нескольких местах проекта одновременно. И мы можем сделать это благодаря инкапсуляции.
Инкапсуляция позволяет добавлять дополнительные ограничения, которые можно превратить в дополнительные преимущества. Например, класс String реализован
как immutable (неизменяемый) объект. Объект класса String неизменяем с момента создания и до момента смерти. Все методы класса String (remove, substring, …),
возвращают новую строку, абсолютно не изменяя объект, у которого они были вызваны.
4 Мы задаем способ взаимодействия нашего объекта со сторонними объектами.
Мы можем ограничить некоторые действия, допустимые с нашим объектом. Например, мы хотим, чтобы объект можно было создать только в одном экземпляре.
Даже если его создание происходит в нескольких местах проекта одновременно. И мы можем сделать это благодаря инкапсуляции.
Инкапсуляция позволяет добавлять дополнительные ограничения, которые можно превратить в дополнительные преимущества.
Например, класс String реализован как immutable (неизменяемый) объект. Объект класса String неизменяем с момента создания и до момента смерти.
Все методы класса String (remove, substring, …), возвращают новую строку, абсолютно не изменяя объект, у которого они были вызваны.


