// Модификаторы доступа, переопределение методов, реализация абстрактных методов
// Перегрузка методов | часть 2
// Создание объекта. Порядок вызова конструкторов
// Порядок загрузки классов, статические данные
// Порядок инициализации переменных

// Модификаторы доступа. Private, protected, default, public https://javarush.com/groups/posts/1988-modifikatorih-dostupa-private-protected-default-public
// Порядок действий при создании объекта https://javarush.com/groups/posts/2137-porjadok-deystviy-pri-sozdanii-obhhekta



Модификаторы доступа, переопределение методов, реализация абстрактных методов
Модификатор public.
К переменной, методу или классу, помеченному модификатором public, можно обращаться из любого места программы. Это самая высокая степень открытости – никаких ограничений нет.
Модификатор private.
К переменной, методу или классу, помеченному модификатором private, можно обращаться только из того же класса, где он объявлен.
Для всех остальных классов помеченный метод или переменная – невидимы. Это самая высокая степень закрытости – только свой класс.
Такие методы не наследуются и не переопределяются. Доступ к ним из класса-наследника также невозможен.
Модификатор «по умолчанию».
Если переменная или метод не помечены никаким модификатором, то считается, что они помечены «модификатором по умолчанию».
Переменные и методы с таким модификатором видны всем классам пакета, в котором они объявлены, и только им.
Этот модификатор еще называют «package» или «package private», намекая, что доступ к переменным и методам открыт для всего пакета, в котором находится их класс
Модификатор «protected».
Этот уровень доступа чуть шире, чем package. К переменной, методу или классу, помеченному модификатором protected, можно обращаться из его же пакета (как package),
но еще из всех классов, унаследованных от текущего.
Кто имеет доступ	            Модификатор	            Пример
Только я сам	                private         	    Личный дневник
Семья	                        (нет модификатора)      Семейные фотографии
Семья и наследники	            protected	            Фамильное поместье
Все	                            public	                Мемуары
Неявная реализация абстрактного метода
class Cat {
 public String getName()  {
   return "Васька";
}}
interface HasName{
 String getName();
 int getWeight();
}
class Tiger extends Cat implements HasName{
 public int getWeight() {
  return 115;
}}
Расширение видимости. При переопределении типа разрешается расширить видимость метода. Вот как это выглядит:
class Cat{
 protected String getName() {
  return "Васька";
}}
class Tiger extends Cat{
 public String getName() {
  return "Василий Тигранович";
}}
Мы расширили видимость метода с protected до public.
В Java перед вызовом метода не проверяется, есть ли такой метод у объекта или нет. Все проверки происходят во время выполнения.
И [гипотетический] вызов отсутствующего метода, скорее всего, приведет к тому, что программа начнет выполнять байт-код там, где его нет.
Это, в конце концов, приведет к фатальной ошибке, и операционная система принудительно закроет программу.

Перегрузка методов | часть 2
В процессе определения метода, который нужно вызвать, типы могут только расширяться, но не сужаться

Создание объекта. Порядок вызова конструкторов
1 Выделяется память под все переменные – поля класса.
2 Инициализация базового класса.
3 Переменным присваиваются значения, если они указаны.
4 Вызывается конструктор.
Вызов конструктора базового класса всегда должен быть в первой строке конструктора.
Если у класса нет ни одного конструктора, он будет создан автоматически.
Если не вызываешь конструктор базового класса, его вызов будет добавлен автоматически.
class Pet extends Object
{
 int x;
 int y;
 int weight;
 Pet(int x, int y)
 {
  //вызов конструктора базового класса
  super();
  //инициализация переменных
  this.x = 5;
  this.y = 5;
  this.weight = 10;
  //вызов кода конструктора
  this.x = x;
  this.y = y;
 }
}
class Cat extends Pet
{
 int tailLength;
 int age;
 Cat(int x, int y, int age)
 {
  //вызов конструктора базового класса
  super(x, y);
  //инициализация переменных
  this.tailLength = 8;
  //вызов кода конструктора
  this.age = age;
 }
}

Порядок загрузки классов, статические данные
Классы в Java – это файлы на диске, содержащие байт-код – скомпилированный Java-код.
— Java-машина не загружает их без необходимости. Как только где-то в коде происходит обращение к классу, Java-машина проверяет – загружен ли он.
И если нет, то загружает и инициализирует его.
Инициализация класса – это присваивание значений всех его статических переменных и вызов всех статических блоков
Если для инициализации переменных объекта нужно выполнить сложный код (например, что-то загрузить из файла), мы можем сделать это в конструкторе.
Статические переменные такой возможности лишены.
Но т.к. потребность в этом осталась, в классы можно добавить статический блок или блоки, которые по сути своей эквивалентны вызову статических конструкторов.

Порядок инициализации переменных
public int a = getSum();
public int b = getSum() - a;
public int c = getSum() - a - b;
Класс загружается сверху вниз, поэтому важно, чтобы поле класса обращалось только к уже загруженным другим полям.
В примере поле b может обращаться к a, но ничего не знает о c.
Когда переменные создаются, они получают дефолтовые значения (значения по умолчанию).
Код
class Cat
{
 public int a = getSum();
 public int b = getSum() - a;
 public int c = getSum() - a - b;
 public int getSum()
 {
  return a + b + c;
 }
}
Что происходит на самом деле
class Cat
{
 public int a = 0;
 public int b = 0;
 public int c = 0;
 public Cat()
 {
  super();
  a = getSum(); //(a+b+c)=0
  b = getSum() - a; //(a+b+c)-a=b=0
  c = getSum() - a - b; //(a+b+c)-a-b=c=0
 }
 public int getSum()
 {
  return a + b + c;
 }
}