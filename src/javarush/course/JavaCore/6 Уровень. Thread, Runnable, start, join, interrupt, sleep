// Многопоточность или многонитевость
// Создание и запуск новых нитей (трэдов)
// join — ожидание завершения нити






Многопоточность или многонитевость
У каждого потока есть свое задание. Нить – это набор команд, выполненных в процессе исполнения этого задания.
Т.к. процессор у компьютера один, то он может выполнять только одну команду одновременно. Поэтому происходит вот что:
процессор постоянно переключается между нитями. Переключился на новую нить, выполнил несколько ее команд, затем переключился на следующую нить,
выполнил несколько ее команд и так далее. Но т.к. переключение между нитями происходит сотни раз в секунду, со стороны кажется, что все нити работают одновременно.

Создание и запуск новых нитей (трэдов)
Чтобы породить новую нить нужно:
1 Создать объект класса Thread (нить)
2 Передать в него объект, метод которого нужно выполнить
3 Вызвать у созданного объекта Thread метод start.
class Printer implements Runnable                                            Класс, который реализует интерфейс Runnable.
{
public void run()
{
System.out.println("I’m printer");
}
}
public static void main(String[] args)
{
Printer printer = new Printer();
Thread childThread = new Thread(printer);
childThread.start();
}
1 Создали объект класса Printer, который содержит метод run.
2 Создали новый объект класса Thread, передали ему в конструкторе объект printer, чей метод run()нужно будет исполнить.
3 Запустили новую нить в работу, вызовом метода start().
Маленькие программы на Java обычно состоят из одной нити, называемой «главной нитью» (main thread).
Но программы побольше часто запускают дополнительные нити, их еще называют «дочерними нитями».
Главная нить выполняет метод main и завершается. Аналогом такого метода main, для дочерних нитей служит метод run интерфейса Runnable
Чтобы указать, с какого именно метода нужно начать выполнение объекту Thread, нужно как-то передать метод этому объекту.
В Java это реализовано с помощью интерфейса Runnable. Этот интерфейс содержит единственный абстрактный метод – void run().
Класс Thread имеет конструктор Thread(Runnable runnable), в который можно передать любой объект, который реализует интерфейс Runnable.
Необходимо унаследовать свой класс от интерфейса Runnable, затем переопределить метод run в своем классе.
Именно с вызова этого метода начнется работа новой нити. В методе run ты можно написать все, что нужно.
Более того, можно совместить это все в одном классе. Класс Thread унаследован от интерфейса Runnable, и достаточно просто переопределить его метод run:
но у него есть минусы:
1 Вам может понадобиться запустить несколько нитей на основе одного единственного объекта, как это сделано в «примере с Наташей».
2 Если вы унаследовались от класса Thread, вы не можете добавить еще один класс-родитель к своему классу.
3 Если у вашего класса есть класс-родитель, вы не можете добавить второго – Thread.

join — ожидание завершения нити
Смысл его в следующем. Одна нить ждет, пока полностью завершится работа второй нити
class Printer implements Runnable                                           Класс, который реализует интерфейс Runnable.
{
private String name;
public Printer(String name)
{
this.name = name;
}
public void run()
{
System.out.println("I’m " + this.name);
}
}
public static void main(String[] args)
{
Printer printer1 = new Printer("Коля");
Thread thread1 = new Thread(printer1);
thread1.start();
thread1.join();
}
Главная нить создает дочернюю нить – объект thread1.
Затем запускает ее – вызов thread1.start();
И ждет ее завершения – thread1.join();
Одна нить может вызвать метод join у объекта второй нити. В результате первая нить (которая вызвала метод) приостанавливает свою работу
до окончания работы второй нити (у объекта которой был вызван метод).
Тут стоит различать две вещи: есть, собственно, нить – отдельный процесс выполнения команд, а есть объект этой нити (объект Thread).
лавная нить после запуска первой дочерней нити может раздать еще много заданий другим нитям (создав их и вызвав метод start),
а потом все – работы ей больше не осталось, нужно обрабатывать результаты работы первой дочерней нити. В таких случаях,
когда нужно обязательно дождаться завершения работы другой нити и нужно вызывать метод join.