// Типы-обертки в Java
// Коллекции в Java: ArrayList
// Выведение типов Java-компилятором
// Параметризированные типы в Java – Generics
// Дженерики

// Обёртки, распаковка и запаковка https://javarush.com/groups/posts/1948-objertki-raspakovka-i-zapakovka
// Класс ArrayList https://javarush.com/groups/posts/klass-arraylist
// Удаление элемента из списка ArrayList https://javarush.com/groups/posts/1935-udalenie-ehlementa-iz-spiska-arraylist
// Java ArrayList в картинках https://javarush.com/groups/posts/1936-rabota-arraylist-v-kartinkakh--



Типы-обертки в Java
В Java есть 8 примитивных типов, которые не являются классами, они простые и занимают мало места, но иногда нужны именно классы
Примитивный тип - обертка: byte Byte, short Short, int Integer, long Long float Float,double Double, char Character, boolean Boolean
Все объекты классов-оберток являются неизменяемыми (immutable).
Преобразование: Integer имя = new Integer(значение); int имя = переменная.примитивValue();

Autoboxing и unboxing
Ваш код	           Что видит компилятор
Integer a = 10;    Integer a = Integer.valueOf(10);
int b = a;         int b = a.intValue(); то есть он сам выворачивает значение для выполнения
Integer c = a + b; Integer c = Integer.valueOf(a.intValue() + b);

Сравнение
Если сравнивать Integer и Integer, происходит сравнение ссылок, а не значений.
Integer a = 1000;
Integer b = 1000;
System.out.println(a == b);
false

Integer a = 1000;
Integer b = 1000;
System.out.println(a.equals(b));
true

Необходимо использовать equal для сравнения Integer c Integer и тп, если один из них int - можно использовать ==.

Класс нужен для того, что у него есть поля и методы

int имя = Integer.parseInt(строка);

У Integer 2 поля: Integer.MAX_VALUE, Integer.MIN_VALUE - тип int
Double 6 полей:
double Double.NEGATIVE_INFINITY Минус бесконечность
double Double.POSITIVE_INFINITY Плюс бесконечность
int Double.MIN_EXPONENT Минимальное значение экспоненты (2x)
int Double.MAX_EXPONENT Максимальное значение экспоненты (2x)
double Double.MIN_VALUE Минимальное значение типа double
double Double.MAX_VALUE Максимальное значение типа double

Если вы разделите -1.0 на 0.0, получите отрицательную бесконечность, если 1.0 на 0.0 — положительную бесконечность.
Тип double может не только делить на ноль, но и хранить такие значения.

Класс ArrayList
массив-список, который выполняет ту же работу, что и Array (массив), но может изменять свой размер.

Хранить элементы определенного типа
Динамически менять размер списка
Добавлять элементы в конец списка
Вставлять элементы в начало и середину списка
Удалять элементы из любого места списка

Создание ArrayList<Тип> имя = new ArrayList<Тип>();
Коллекции, в отличие от массивов, не могут хранить примитивные типы: только типы-классы. Поэтому если вам нужна
коллекция с типом int, используйте вместо него тип-обертку — Integer.
Устройство ArrayList простое и гениальное по своей сути. Внутри каждого объекта ArrayList есть два поля:
- Массив со списком элементов
- Переменная size, которая хранит количество элементов списка
Если при добавлении очередного элемента в список в массиве уже нет места, в методе add() происходит следующее:
- создается новый массив в полтора раза длиннее предыдущего (изначально capacity = 10)
- в него копируются все элементы из существующего массива
- в объекте ArrayList вместо старого массива сохраняется ссылка на новый.
- В 10-ю ячейку нового массива записывается переданный элемент
- size увеличивается на 1 и теперь будет равняться 11

list.add(5, 10000); list.remove(3); indexOf();

Выведение типов Java-компилятором
Хитрые особенности языка, которые позволяют использовать более короткий путь (писать меньше кода), называют
синтаксическим сахаром. Хотя, честно говоря, в Java его совсем немного. (например это autoboxing и unboxing)
Длинный код	Компактный код
Integer a = new Integer(5); int b = a.intValue();
Integer a = 5;              int b = a;

В Java 11 компилятор стал еще умнее и теперь может определить тип создаваемой переменной по типу значения, которое ей присваивают. Выглядит это в коде так:
var имя = значение;
Пустые треугольные скобки (справа, после new) в типе коллекции получили название оператор diamond: две скобки отдаленно напоминали силуэт бриллианта.
Не использовать с var

В Java 11 компилятор стал еще умнее и теперь может определить тип создаваемой переменной по типу значения, которое ей присваивают. Выглядит это в коде так:

Двойные фигурные скобки
С сахаром
var list = new ArrayList<String>()
{{
   add("Привет");
   add("Как");
   add("Дела");
}};

Без сахара
var list = new ArrayList<String>();
list.add("Привет");
list.add("Как");
list.add("Дела");

Параметризированные типы в Java – Generics
Все классы в Java неявно (скрытно) унаследованы от класса Object.
Переменной типа Object можно присвоить объект любого класса.
На этом хорошие новости заканчиваются. Компилятор не следит за тем, объект какого именно типа был сохранен в переменную
типа Object, поэтому вызвать методы, которые были у сохраненного объекта, но которых нет у переменной типа Object нельзя.
В Java есть способ проверить, какой на самом деле тип находится внутри переменной:
имя instanceof Тип
Оператор instanceof проверяет, является ли переменная имя объектом типа Тип.

Дженерики
Под дженериками в Java подразумевают возможность добавлять к типам типы-параметры. Таким образом получаются сложные
составные типы. Такой составной тип в общем случае выглядит так:
ОсновнойТип<ТипПараметр>
Как работают Generics:
На самом деле Generics работают до ужаса примитивно.
Компилятор просто заменяет тип с параметром на него же, только без параметра. А при взаимодействии с его методами
добавляет операцию приведения типа к типу-параметру
Т.е. по сути дженерики — это такая разновидность синтаксического сахара, как и autoboxing, только побольше. При autoboxing
компилятор за нас добавляет методы для преобразования типа int к Integer и обратно, а для generics добавляет операторы приведения типа.