// Оператор try with resources
// Потоки для ввода данных
// Цепочки потоков
// Потоки вывода
// Знакомство с файлами
// Работа с сетью

// Ввод-вывод в Java. Классы FileInputStream, FileOutputStream, BufferedInputStream
https://javarush.com/groups/posts/2020-vvod-vihvod-v-java-klassih-fileinputstream-fileoutputstream-bufferedinputstream
// Java Files, Path https://javarush.com/groups/posts/2275



Оператор try with resources
Иногда в процессе работы Java-программа взаимодействует с объектами вне Java-машины. Например, с файлами на диске.
Такие объекты принято называть внешними ресурсами. Внутренние ресурсы — это объекты, созданные внутри Java-машины.
Java программа -> Java машина -> Операционная система -> Файлы/Другие ресурсы
Операционная система ведет строгий учет доступных ресурсов, а также контролирует совместный доступ разных программ к ним.
Например, если одна программа меняет какой-то файл, другая программа не может изменить (или удалить) этот файл.
Это касается не только файлов, но на их примере понятнее всего.
У операционной системы есть функции (API), которые позволяют программе захватить какой-либо ресурс и/или освободить его.
Если ресурс занят, с ним может работать только та программа, которая его захватила. Если ресурс свободен, любая программа может захватить его.
У классов, которые используют внешние ресурсы, есть специальный метод для их освобождения — close().
try-with-resources (доступно с 7 версии java)
Он создан как раз для того, чтобы решать проблему с обязательным вызовом метода close().
try (Класс имя = new Класс())
{
     Код, который работает с переменной имя
}
Это еще одна разновидность оператора try. После ключевого слова try нужно добавить круглые скобки, а внутри них — создать
объекты с внешними ресурсами. Для объекта, указанного в круглых скобках, компилятор сам добавит секцию finally и вызов метода close().
Несколько переменных одновременно
try (Класс имя = new Класс(); Класс2 имя2 = new Класс2())
{
   Код, который работает с переменной имя и имя2
}
Интерфейс AutoCloseable
Как будет работать оператор try-with-resources, если у класса нет метода close() - ничего не вызовется. Нет метода, нет проблем.
А как будет работать try-with-resources если у класса есть несколько методов close()? И им нужно передавать параметры? И у класса нет метода close() без параметров?
Для того чтобы таких вопросов не было, создатели Java придумали специальный класс (интерфейс) AutoCloseable у которого только один метод – close() без параметров.

Потоки для ввода данных
Сам процесс обмена данными можно разделить на два типа: получение данных и отправка данных. Например, вы считываете данные
с клавиатуры с помощью объекта Scanner — это получение данных. И выводите данные на экран с помощью команды System.out.println() — это отправка данных.
Для описания процесса обмена данными в программировании используется термин поток.
Чтобы потоки можно было «потрогать руками», разработчики Java написали два класса: InputStream и OutputStream.
У класса InputStream есть метод read(), который позволяет читать из него данные. А у класса OutputStream есть метод write(),
который позволяет записывать в него данные. У них есть и другие методы, но об этом после.
Байтовые потоки
Это универсальные классы, и поэтому они поддерживают самый распространённый тип данных — byte. В OutputStream можно
записывать байты (и массивы байт), а из объекта InputStream можно читать байты (или массивы байт). Все — никакие другие типы данных они не поддерживают.
Поэтому такие потоки еще называют байтовыми потоками.
Особенность потоков в том, что данные из них можно читать (писать) только последовательно. Вы не можете прочитать данные
из середины потока, не прочитав все данные перед ними.
Символьные потоки
Недавно вы изучали, что строки — второй по популярности тип данных, и это действительно так. Очень много информации
передается в виде символов и целых строк. Компьютер отлично бы передавал все в виде байт, но люди не настолько идеальны.
Java-программисты учли этот факт и написали еще два класса: Reader и Writer. Класс Reader — это аналог класса InputStream,
только его метод read() читает не байты, а символы — char. Класс Writer соответствует классу OutputStream, и так же, как и
класс Reader, работает с символами (char), а не байтами.
	            Байты (byte)	Символы (char)
Чтение данных	InputStream     Reader
Запись данных	OutputStream    Writer
InputStream
Методы	                Описание
int read()              Читает один байт из потока
int read(byte[] buffer) Читает массив байт из потока
byte[] readAllBytes()   Читает все байты из потока
long skip(long n)       Пропускает n байт в потоке (читает и выкидывает)
int available()         Проверяет, сколько байт еще осталось в потоке
void close()            Закрывает поток
Класс Reader
Методы	                Описание
int read()              Читает один char из потока
int read(char[] buffer) Читает массив char’ов из потока
long skip(long n)       Пропускает n char’ов в потоке (читает и выбрасывает)
boolean ready()         Проверяет, что в потоке еще что-то осталось
void close()            Закрывает поток

Цепочки потоков
InputStreamReader
Основное отличие классов InputStreamReader и, например, FileReader в том, откуда они читают данные. FileReader читает
данные из файла (поэтому он и называется FileReader), а InputStreamReader читает данные из потока InputStream.
BufferedReader
Это тоже «промежуточный поток», который читает данные из другого потока.
Класс BufferedReader, как видно из его названия, является классом-наследником от Reader и позволяет читать символы.
Однако, что самое интересное, в качестве источника данных в него тоже нужно передать поток, из которого можно читать символы – поток-наследник от класса Reader.
Когда программа читает из объекта BufferedReader один символ, он читает из своего потока-источника сразу большой массив символов. И сохраняет их у себя внутри.
При чтении следующего символа из объекта BufferedReader, он просто возьмет очередной символ из своего внутреннего массива-буфера и отдаст его,
не обращаясь при этом к потоку-источнику данных. И только когда все символы в буфере закончатся, он снова прочитает большой массив символов.
Еще у класса BufferedReader есть очень полезный метод — String readLine(), который позволяет читать данные из потока-источника сразу строками.
Чтение с консоли
Класс Scanner — ничто иное как входящий промежуточный поток данных, который читает их из потока System.in — тоже потока данных.

Потоки вывода
OutputStream
Методы	                    Описание
void write(int b)           Записывает один байт (не int) в поток
void write(byte[] buffer)   Записывает массив байт в поток
void write(byte[] buffer, off, len) Записывает часть массива байт в поток
void flush()                Записывает в поток все данные, которые хранятся в буфере
void close()                Закрывает поток
Writer
Методы	                    Описание
void write(int b)           Записывает один символ (не int) в поток
void write(char[] buffer)   Записывает массив символов в поток
void write(char[] buffer, off, len) Записывает часть массива символов в поток
void write(String str)      Записывает строку в поток
void write(String str, off, len)    Записывает часть строки в поток
void flush()                Записывает в поток все данные, которые хранятся в буфере
void close()                Закрывает поток
StringWriter
Есть еще один интересный класс-наследник от класса Writer — это StringWriter. В нем находится изменяемая строка — объект StringBuffer.
И каждый раз, когда вы что-то «пишете» в объект StringWriter, текст просто добавляется во внутренний буфер.
PrintStream
Методы	                    Описание
void print(obj)             Преобразует переданной объект в строку и выводит в целевой поток.
void println(obj)           Преобразует переданный объект в строку и выводит в целевой поток. Добавляет в конце символ переноса строки
void println()              Выводит в целевой поток символ переноса строки
PrintStream format(String format, args...) Конструирует и выводит строку на основе строки шаблона и переданных аргументов, по аналогии с методом String.format()

Знакомство с файлами
Path
В ранних версиях Java для работы с файлами использовались классы типа File и FileInputStream.
Но теперь класс File считается устаревшим, и использовать его не рекомендуется.
Метод	                    Описание
Path getParent()            Возвращает родительскую директорию
Path getFileName()          Возвращает имя файла без директории
Path getRoot()              Возвращает корневую директорию из пути
boolean isAbsolute()        Проверяет, что текущий путь — абсолютный
Path toAbsolutePath()       Преобразует путь в абсолютный
Path normalize()            Убирает шаблоны в имени директории
Path resolve(Path other)    Строит новый абсолютный путь из абсолютного и относительного
Path relativize(Path other) Получает относительный путь из двух абсолютных путей
boolean startsWith(Path other)  Проверяет, что текущий путь начинается с пути
boolean endsWith(Path other)    Проверяет, что текущий путь заканчивается на путь
int getNameCount()          Дробит путь на части с помощью разделителя /. Возвращает количество частей
Path getName(int index)     Дробит путь на части с помощью разделителя /. Возвращает часть по ее номеру
Path subpath(int beginIndex, int endIndex)  Дробит путь на части с помощью разделителя /. Возвращает часть пути, заданную интервалом.
File toFile()               Преобразует объект Path в устаревший объект File
URI toUri()                 Преобразует объект Path в объект типа URI
Абсолютный и относительный пути
Пути бывают двух типов: абсолютные и относительные. Абсолютный путь начинается с корневой директории.
Для Windows это может быть папка c:\, для Linux — директория /
Относительный путь считается относительно какой-то директории. Т.е. это как бы конец пути, но только без начала.
Относительный путь можно превратить в абсолютный и наоборот
Files
Метод	                            Описание
Path createFile(Path path)          Создает новый файл с путем path
Path createDirectory(Path path)     Создает новую директорию
Path createDirectories(Path path)   Создает несколько директорий
Path createTempFile(prefix, suffix) Создает временный файл
Path createTempDirectory(prefix)    Создает временную директорию
void delete(Path path)              Удаляет файл или директорию, если она пуста
Path copy(Path src, Path dest)      Копирует файл
Path move(Path src, Path dest)      Перемещает файл
boolean isDirectory(Path path)      Проверяет, что путь — это директория, а не файл
boolean isRegularFile(Path path)    Проверяет, что путь — это файл, а не директория
boolean exists(Path path)           Проверяет, что объект по заданному пути существует
long size(Path path)                Возвращает размер файла
byte[] readAllBytes(Path path)      Возвращает все содержимое файла в виде массива байт
String readString(Path path)        Возвращает все содержимое файла в виде строки
List<String> readAllLines(Path path)Возвращает все содержимое файла в виде списка строк
Path write(Path path, byte[])       Записывает в файл массив байт
Path writeString(Path path, String str) Записывает в файл строку
DirectoryStream<Path> newDirectoryStream(Path dir)  Возвращает коллекцию файлов (и поддиректорий) из заданной директории

Работа с сетью
URL
URL — это такой аналог File или Path, только Path хранит путь к ресурсу в файловой системе, а URL — путь к ресурсу в интернете.
Вся магия происходит, когда мы за один вызов метода openStream() получаем сразу объект типа InputStream.
Работа с интернетом
URL url = new URL("https://javarush.com");
InputStream input = url.openStream();
byte[] buffer = input.readAllBytes();
String str = new String(buffer);
System.out.println(str);
Работа с файлом
File file = new File("c:\\readme.txt");
InputStream input = new FileInputStream(file);
byte[] buffer = input.readAllBytes();
String str = new String(buffer);
System.out.println(str);
URLConnection
Код	                                                        Примечание
URL url = new URL("https://javarush.com");                  Создаем объект URL с путем к странице
URLConnection connection = url.openConnection();            Создаем двустороннее соединение
// получили поток для отправки данных
OutputStream output = connection.getOutputStream();         Получаем поток вывода
output.write(1); // отправляем данные                       Выводим в него данные
// получили поток для чтения данных
InputStream input = connection.getInputStream();            Получаем поток ввода
int data = input.read(); // читаем данные                   Читаем из него данные