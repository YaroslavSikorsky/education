ПОТОКИ

Так в чем же отличие между многими процессами и потоками исполнения? Оно состоит в следующем: если у каждого процесса
имеется собственный набор переменных, то потоки исполнения могут разделять одни и те же общие данные. Это кажется
несколько рискованным, и на самом деле так оно и есть.

Процедура для исполнения задачи в отдельном потоке.
1. Введите код выполняемой задачи в тело метода run() из класса, реализующего интерфейс Runnable. Этот интерфейс очень
прост и содержит следующий единственный метод:
public interface Runnable{
    void run();
}
2. Интерфейс Runnable является функциональным, и поэтому его экземпляр можно создать с помощью лямбда-выражения следующим образом:
Runnable г = () -> { код задачи } ;
3. Сконструируйте объект типа Thread из объекта г типа Runnable, как показано ниже.
Thread t = new Thread(г);
4. Запустите поток на исполнение следующим образом:
t .start ();

Чтобы ввести рассматриваемую здесь программу анимации скачущего мяча в отдельный поток исполнения, достаточно ввести код
анимации скачущего мяча в тело метода run () и запустить поток на исполнение:
Runnable г = () -> {
try {
    for (int i = 1; i <= STEPS; i++){
        ball.move(comp.getBounds());
        comp.repaint();
        Thread.sleep(DELAY);
    }
}
    catch (InterruptedException e)
    {
    }
};
    Thread t = new Thread(r);
    t .start();

Когда данные загружаются по сетевому соединению, нередко приходится иметь дело с задачами, которые на самом деле
следовало бы прервать. Допустим, вы загружаете крупное изображение и, увидев его часть, решаете, что вам не нужно
видеть остальное. Очевидно, что было бы неплохо иметь возможность щелчком на кнопке Stop (Останов) или Back (Назад)
прервать процесс загрузки.

Существуют два очень похожих метода: interrupted() и islnterrupted(). Статический метод interrupted() проверяет, был ли
прерван текущий поток исполнения. Более того, вызов этого метода приводит к очистке состояния прерывания потока исполнения.
С другой стороны, метод экземпляра isinterrupted() можно использовать для проверки, был ли прерван любой поток исполнения.
Его вызов не приводит к изменению состояния прерывания.

Прерывание в вызывающей части программы.
void mySubTask() throws InterruptedException
{
    sleep(delay);
}

• void interrupt()
Посылает потоку исполнения запрос на прерывание. Признак состояния прерывания потока исполнения устанавливается равным
логическому значению true. Если поток в данный момент блокирован вызовом метода sleep(), генерируется исключение
типа InterruptedException.
• static boolean interrupted()
Проверяет, был ли прерван текущий поток исполнения. Следует, однако, иметь в виду, что это статический метод. Его вызов
 имеет побочный эффект: признак состояния прерывания текущего потока исполнения устанавливается равным логическому значению false.
• boolean islnterrupted()
Проверяет, был ли прерван поток исполнения. В отличие от статического метода interrupted(), вызов этого метода не изменяет
 состояние прерывания потока исполнения.
• static Thread currentThreadО
Возвращает объект типа Thread, представляющий текущий поток исполнения.

 void join()
Ожидает завершения указанного потока.
• void join(long millis)
Ожидает завершения указанного потока исполнения или истечения заданного периода времени.
• Thread.State getStateO 5.0
Получает состояние данного потока исполнения. Может принимать значения NEW, RUNNABLE, BLOCKED, WAITING, TIMEDJWAITING
ИЛИ TERMINATED.
• void stop()
Останавливает поток исполнения. Этот метод не рекомендован к применению.
• void suspend()
Временно приостанавливает поток исполнения. Этот метод не рекомендован к применению.
• void resume()
Возобновляет поток исполнения. Вызывается только после вызова метода suspend(). Этот метод не рекомендован к применению.
• void setDaemon (boolean is Daemon)
Помечает данный поток исполнения как демон или пользовательский поток. Этот метод должен
вызываться перед запуском потока исполнения.

Состояния потоков исполнения
• новый
• исполняемый - как только вызывается метод start()
• блокированный
• ожидающий
• временно ожидающий
• завершенный.
Чтобы определить текущее состояние потока исполнения, достаточно вызвать метод getState().

Блокировка для защиты метода transfer() из класса Bank, как показано ниже.
public class Bank{
    private Lock bankLock = new ReentrantLock(); // объект класса
    // ReentrantLock, реализующего интерфейс Lock
    public void transfer(int from, int to, int amount){
        bankLock.lock();
        try{
            System.out.print(Thread.currentThread());
            accounts[from] -= amount;
            System.out.printf(" %10.2f from %d to %d", amount, from, to);
            accounts[to] += amount;
            System.out.printf(
            " Total Balance: %10.2f%n", getTotalBalance());
        }
        finally{
            bankLock.unlock();
        }
    }
}

• void lock О
Захватывает блокировку. Если же в данный момент она захвачена другим потоком, текущий поток
блокируется.
• void unlock ()
Снимает блокировку.

синхронайзед

монитор

блокирующие очереди

пулы потоков исполнения

плановое исполнение потоков 14.9.2

свинг 14.11